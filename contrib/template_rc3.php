<?php
/**
*
* @package MX-Publisher Module - mx_xs
* @version $Id: template.php,v 1.42 2014/05/16 18:02:06 orynider Exp $
* @copyright (c) 2002-2008 [CyberAlien, OryNider] MX-Publisher Project Team
* @license http://opensource.org/licenses/gpl-license.php GNU General Public License v2
* @link http://mxpcms.sourceforge.net/
*
*/

/***************************************************************************
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 ***************************************************************************/

/**
*
* @Extra credits for this file
* Vjacheslav Trushkin (http://www.stsoftware.biz)
*
*/

/**
 *
 * Template class. By Nathan Codding of the phpBB group.
 * The interface was originally inspired by PHPLib templates,
 * and the template file formats are quite similar.
 *
 * eXtreme Styles mod/module by CyberAlien.
 *
 * IF, ELSEIF, ENDIF tags are backported from phpBB 2.2
 *
 * Documentation for this mod can be found here:
 * http://www.stsoftware.biz/forum
 *
 * Support for eXtreme Styles mod is provided at http://www.stsoftware.biz/forum
 *
 * Thanks to DMaJ007 for idea on how to include some extra tags.
 *
 */

if (!defined('IN_PORTAL'))
{
	die('Hacking attempt');
}

define('XS_SEPARATOR', '.');
define('XS_DIR_CACHE', 'cache');
define('XS_USE_ISSET', '1');

// cache filenames prefix
define('XS_TPL_PREFIX', 'tpl_');
define('XS_TPL_PREFIX2', 'tpl2_');

// templates directory
define('XS_TPL_START', 'templates/');
define('XS_TPL_ANY', '/templates/');

// internal xs mod definitions. do not edit.
define('XS_TAG_NONE', 0);
define('XS_TAG_PHP', 1);
define('XS_TAG_BEGIN', 2);
define('XS_TAG_END', 3);
define('XS_TAG_INCLUDE', 4);
define('XS_TAG_IF', 5);
define('XS_TAG_ELSE', 6);
define('XS_TAG_ELSEIF', 7);
define('XS_TAG_ENDIF', 8);
define('XS_TAG_DEFINE', 9);
define('XS_TAG_UNDEFINE', 10);
define('XS_TAG_BEGINELSE', 11);
define('XS_TAG_ALIAS', 12);

define('ALIAS', 12);
define('NONE', 0);
define('PHP', 1);
define('BEGIN', 2);
define('END', 3);
define('INCLUDE', 4);
define('IF', 5);
define('ELSE', 6);
define('ELSEIF', 7);
define('ENDIF', 8);
define('DEFINE', 9);
define('UNDEFINE', 10);
define('BEGINELSE', 11);
class Template 
{
	var $classname = "Template";

	// variable that holds all the data we'll be substituting into
	// the compiled templates.
	var $tpldata = array('.' => array(0 => array()));
	// This will end up being a multi-dimensional array like this:
	// $this->_tpldata[block.][iteration#][child.][iteration#][child2.][iteration#][variablename] == value
	// if it's a root-level variable, it'll be like this:
	// $this->vars[varname] == value  or  $this->_tpldata['.'][0][varname] == value
	// array "vars" is added for easier access to data
	var $_tpldata = array('.' => array(0 => array()), 'DEFINE' => array(9 => array()));	
	var $vars;

	// Hash of filenames for each template handle.
	var $files = array();
	var $files_cache = array(); // array of cache files that exists
	var $files_cache2 = array(); // array of cache files (exists or not exists)

	// Root template directory.
	var $root = '';

	// Cache directory (compatible with default cache class)
	var $cachedir = '';

	
	// Style directory (compatible with default templates class)
	var $template_path = XS_TPL_START;

	// Search/replace for unknown files
	var $mx_cache_search = array();
	var $mx_cache_replace = array();

	// Template root directory (generated by set_rootdir)
	var $tpldir = '';
	var $tpldir_len = 0;

	// Default template directory.
	// If file for default template isn't found file from this template is used.
	//var $tpldef = 'subSilver';
	var $tpldef = '_core';

	// this will hash handle names to the compiled code for that handle.
	var $compiled_code = array();

	// This will hold the uncompiled code for that handle.
	var $uncompiled_code = array();

	// Cache settings
	var $use_cache = 1;
	var $cache_writable = 1;

	// Auto-compile setting
	var $auto_compile = 1;

	// Current template name
	var $tpl = '';

	// List of replacements. tpl files in this list will be replaced with other tpl files
	// according to configuration in xs.cfg
	var $replace = array();

	// counter for include
	var $include_count = 0;

	// php extension. will be replaced by $phpEx in Template() function unless you disable it there
	var $php = 'php';

	// True if check switches
	var $xs_check_switches = 1;

	// eXtreme Styles variables
	var $xs_started = 0;
	var $xs_version = 8; // number version. internal. do not change.
	var $xs_versiontxt = '2.4.1'; // text version

	// These handles will be parsed if pparse() is executed.
	// Can be used to automatically include header/footer if there is any content.
	var $preparse = '';
	var $postparse = '';

	// subtemplates mod detection
	var $subtemplates = false;

	// style configuration
	var $style_config = array();

	// list of switches that are known typos in some mods.
	// when error checking is enabled these errors will be auto-fixed.
	// format:
	//  array(start_tag, end_tag)
	var $bugs = array(
		// ezportal typo:
		array('fetchpost_row', 'fetch_post_row'),
		// mycalendar 2.2.7 typos:
		array('date_cell', 'date_cells'),
		array('date_row', 'date_rows'),
		// history mod typo:
		array('site_today', 'site_week'),
		);
	
	/**
	* Constructor
	*
	* @param $mx_user
	*/
	public function __construct()
	{
		global $mx_cache, $mx_user; 
		
		$this->cache = $mx_cache;
		$this->user = $mx_user;
	}
	
	/**
	 * Constructor. Installs XS mod on first run or updates it and sets the root dir.
	 */
	function Template($root = '.')
	{
		global $mx_cache, $mx_user; 
		
		$this->cache = $mx_cache;
		$this->user = $mx_user;		
		
		// setting pointer "vars"
		$this->vars = &$this->_tpldata['.'][0];
		// load configuration
		$this->load_config($root, true);
	}

	/**
	 * Load mod configuration
	 */
	function load_config($root, $edit_db)
	{
		global $mx_cache, $board_config, $portal_config, $phpbb_root_path, $mx_root_path, $phpEx, $mx_backend;

		$edit_db = $mx_backend->edit_db;

		// getting mod version from config and comparing with real data
		$ver = isset($board_config['xs_version']) ? $board_config['xs_version'] : ( isset($portal_config['xs_version']) ? $portal_config['xs_version'] : 0 );
		// check configuration
		// set config values if there aren't any
		$add = array();
		$del = array();
		$up = array();
		// list of outdated variables
		$outdated = array(
			'xs_versoin',	// was a typo in one of previous versions
			'xs_separator',	// no longer used
			'xs_cache_dir_absolute',	// no longer used
			'xs_cache_dir',	// no longer used
			'xs_use_isset',	// no longer used
			);
		// list of default values
		$default = array(
			'xs_auto_compile'			=> 1,
			'xs_auto_recompile'			=> 1,
			'xs_use_cache'				=> 1,
			'xs_php'					=> $phpEx,
			'xs_def_template'			=> 'subSilver',
			'xs_check_switches'			=> 1,
			'xs_warn_includes'			=> 1,
			'xs_add_comments'			=> 0,
			'xs_ftp_host'				=> '',
			'xs_ftp_login'				=> '',
			'xs_ftp_path'				=> '',
			'xs_downloads_count'		=> '0',
			'xs_downloads_default'		=> '0',
			'xs_shownav'				=> '1',
			'xs_template_time'			=> '0',
			);
		// checking if all variables exist
		foreach($default as $var => $value)
		{
			if(!isset($board_config[$var]))
			{
				$board_config[$var] = $value;
				$add[] = $var;
			}
		}
		// checking if there are any outdated variables that should be deleted
		for($i=0; $i<count($outdated); $i++)
		{
			if(isset($board_config[$outdated[$i]]))
			{
				$del[] = $outdated[$i];
			}
		}
		if(!isset($board_config['xs_version']))
		{
			$board_config['xs_version'] = $this->xs_version;
			$add[] = 'xs_version';
		}
		elseif($board_config['xs_version'] != $this->xs_version)
		{
			$board_config['xs_version'] = $this->xs_version;
			$up[] = 'xs_version';
		}
		// check config
		if(!empty($board_config['xs_auto_recompile']))
		{
			if(!$board_config['xs_auto_compile'])
			{
				$board_config['xs_auto_compile'] = 1;
				if(!in_array('xs_auto_compile', $up) && !in_array('xs_auto_compile', $add))
				{
					$up[] = 'xs_auto_compile';
				}
			}
		}
		// install/upgrade
		if($edit_db && ((count($add) > 0) || (count($up) > 0) || (count($del) > 0)))
		{
			$board_config['xs_template_time'] = time();
			if(!in_array('xs_template_time', $up))
			{
				$up[] = 'xs_template_time';
			}
			global $db;
			if(!empty($db))
			{
				// adding new config values
				for($i=0; $i<count($add); $i++)
				{
					$sql = "INSERT INTO " . CONFIG_TABLE . " (config_name, config_value) VALUES ('" . $add[$i] . "', '" . str_replace('\\\'', '\'\'', addslashes($board_config[$add[$i]])) . "')";
					$db->sql_query($sql);
				}
				// removing old configuration variables that aren't used
				for($i=0; $i<count($del); $i++)
				{
					$sql = "DELETE FROM " . CONFIG_TABLE . " WHERE config_name='" . $del[$i] . "'";
					$db->sql_query($sql);
				}
				// updating variables that should be overwritten
				for($i=0; $i<count($up); $i++)
				{
					$sql = "UPDATE " . CONFIG_TABLE . " SET config_value='" . str_replace('\\\'', '\'\'', addslashes($board_config[$up[$i]])) . "' WHERE config_name='" . $up[$i] . "'";
					$mx_cache->put( 'phpbb_config', $board_config );
					$db->sql_query($sql);
				}
				// recache config table for cat_hierarchy 2.1.0
				global $config;
				if(isset($config->data) && $config->data === $board_config && isset($config->data['mod_cat_hierarchy']))
				{
					$config->read(true);
				}
			}
		}
		$this->php = isset($board_config['xs_php']) ? $board_config['xs_php'] : ( isset($portal_config['xs_php']) ? $portal_config['xs_php'] : '' );
		$this->tpldef = isset($board_config['xs_def_template']) ? $board_config['xs_def_template'] : ( isset($portal_config['xs_def_template']) ? $portal_config['xs_def_template'] : '' );
		$this->use_cache = isset($board_config['xs_use_cache']) ? $board_config['xs_use_cache'] : ( isset($portal_config['xs_use_cache']) ? $portal_config['xs_use_cache'] : '' );
		$this->auto_compile = isset($board_config['xs_auto_compile']) ? $board_config['xs_auto_compile'] : ( isset($portal_config['xs_auto_compile']) ? $portal_config['xs_auto_compile'] : '' );
		$this->xs_check_switches = isset($board_config['xs_check_switches']) ? $board_config['xs_check_switches'] : ( isset($portal_config['xs_check_switches']) ? $portal_config['xs_check_switches'] : '' );
		$this->cache_search = array('.', '\\', '/', '_tpl');
		$this->cache_replace = array('_', XS_SEPARATOR, XS_SEPARATOR, '.'.$this->php);
		$old_root = $this->root;
		$this->set_rootdir($root);
		// Mighty Gorgon - Common TPL - BEGIN
		$cfg_path = $this->tpl;
		if ((defined('IN_PHPBB') || defined('IN_ADMIN')))
		{
			$cfg_path = 'all';
		}
		// Mighty Gorgon - Common TPL - END
		if(!empty($this->tpl))
		{
			if($this->tpldef != $cfg_path)
			{
				$file = $this->tpldir . $this->tpldef . '/xs.cfg';
				$this->load_replacements($file);
			}
			$file = $this->tpldir . $cfg_path . '/xs.cfg';
			$this->load_replacements($file);
		}
		if($old_root !== $this->root)
		{
			$this->clear_files();
		}
	}

	/**
	 * Sets the template root directory for this Template object.
	 */
	function set_rootdir($dir)
	{
		global $board_config, $phpbb_root_path, $mx_root_path;
		if (!@is_dir($dir))
		{
			return false;
		}
		$dir = str_replace('\\', '/', $dir);
		// creating absolute path for cache
		$this->cachedir = $mx_root_path . XS_DIR_CACHE . '/';
		// creating absolute path for current template and root dir
		$this->tpldir = $mx_root_path . 'templates/';
		$this->tpldir_len = strlen($this->tpldir);
		$this->root = $dir;
		$this->tpl = $this->template_name($dir);
		// check configuration
		$this->get_config();
		// check subtemplates mod
		$sub_templates_cfg = $this->root . '/sub_templates.cfg';
		if(defined('LANG_EXTEND_DONE') && @file_exists($sub_templates_cfg))
		{
			$this->subtemplates = true;
		}
		return true;
	}

	/**
	* Set custom template location (able to use directory outside of phpBB)
	* @access public
	*/
	function set_custom_template2($template_path, $template_name)
	{
		global $board_config, $phpbb_root_path, $mx_root_path;

		$this->root = $template_path;
		$this->cachepath = $mx_root_path . 'cache/ctpl_' . $template_name . '_';
		$this->cachedir = $mx_root_path . XS_DIR_CACHE . '/';

		return true;
	}

	/**
	 * Destroys this template object. Should be called when you're done with it, in order
	 * to clear out the template data so you can load/parse a new template set.
	 */
	function destroy()
	{
		$this->_tpldata = array('.' => array(0 => array()));
		$this->vars = &$this->_tpldata['.'][0];
		//$this->_rootref = &$this->_tpldata['.'][0];		
		$this->xs_started = 0;
	}
	
	/**
	* Reset/empty complete block
	* @access public
	*/
	function destroy_block_vars($blockname)
	{
		if (strpos($blockname, '.') !== false)
		{
			// Nested block.
			$blocks = explode('.', $blockname);
			$blockcount = sizeof($blocks) - 1;

			$str = &$this->_tpldata;
			for ($i = 0; $i < $blockcount; $i++)
			{
				$str = &$str[$blocks[$i]];
				$str = &$str[sizeof($str) - 1];
			}

			unset($str[$blocks[$blockcount]]);
		}
		else
		{
			// Top-level block.
			unset($this->_tpldata[$blockname]);
		}

		return true;
	}
	
	/**
	 * Clears list of compiled files.
	 */
	function clear_files()
	{
		$this->files = array();
		$this->files_cache = array();
		$this->files_cache2 = array();
		$this->compiled_code = array();
		$this->uncompiled_code = array();
	}

	/**
	 * Loads replacements from .cfg file
	 */
	function load_replacements($file)
	{	
		global $mx_root_path, $phpbb_root_path;
		
		if (!file_exists($file) && !file_exists($mx_root_path . $file) && !file_exists($phpbb_root_path . $file))
		{
			// trigger_error cannot be used here, as the output already started
			//echo 'template->_php_include(): File ' . htmlspecialchars($file) . ' does not exist or is empty';
			return;
		}		
		
		if(@file_exists($file))
		{
			$replace = array();
			@include($file);
			$this->replace = array_merge($this->replace, $replace);
		}
		elseif(@file_exists($phpbb_root_path . $file))
		{
			$replace = array();
			@include($phpbb_root_path . $file);
			$this->replace = array_merge($this->replace, $replace);
		}
		elseif(@file_exists($mx_root_path . $file))
		{
			$replace = array();
			@include($mx_root_path . $file);
			$this->replace = array_merge($this->replace, $replace);
		}		
	}

	/**
	 * Extracts template name from path
	 */
	function template_name($dir)
	{
		$tpl = XS_TPL_ANY; // can start at any position
		$tpl_null = XS_TPL_START; // can start only at zero position
		// searching for 'templates/' and removing everything before it
		$pos = strpos($dir, $tpl);
		if($pos === false)
		{
			if(substr($dir, 0, strlen($tpl_null)) !== $tpl_null)
			{
				return '';
			}
			$str = substr($dir, strlen($tpl_null), strlen($dir));
		}
		else
		{
			$str = substr($dir, $pos + strlen($tpl), strlen($dir));
		}
		// searching for one more 'templates/'
		// that can happen if full path is like /home/some_dude/templates/phpbb/templates/subSilver/
		$dir = $this->template_name($str);
		if(!$dir)
		{
			$dir = $str;
		}
		if(strpos($str, $tpl) !== false)
		{
			$dir = $this->template_name($str);
		}
		// check for another subdirectory
		$pos = strpos($dir, '/');
		if($pos)
		{
			$dir = substr($dir, 0, $pos);
		}
		return $dir;
	}

	function subtemplates_make_filename($filename)
	{
		global $mx_request_vars, $db, $board_config, $images, $theme;
		global $sub_template_key_image, $sub_templates;
		global $tree;

		// initiate the sub-template image pack that will be use
		$sub_template_key_image = POST_CAT_URL . '0';

		// Check if sub_templates are defined for this theme
		if ( $board_config['version'] > '.0.5' )
		{
			$sub_templates_cfg = mx_realpath($this->root . '/sub_templates.cfg');
		}
		else
		{
			$sub_templates_cfg = $this->root . '/sub_templates.cfg';
		}
		@include($sub_templates_cfg);
		if ( isset($sub_templates) )
		{
			// search an id
			$cat_id = 0;
			$forum_id = 0;
			$topic_id = 0;
			$post_id = 0;

			if ( !defined('IN_PRIVMSG') && $mx_request_vars->is_request(POST_POST_URL))
			{
				$post_id = $mx_request_vars->request(POST_POST_URL, MX_TYPE_INT);
			}

			if ($mx_request_vars->is_request(POST_TOPIC_URL) )
			{
				$topic_id = $mx_request_vars->request(POST_TOPIC_URL, MX_TYPE_INT);
			}

			if ($mx_request_vars->is_request(POST_FORUM_URL))
			{
				$forum_id = $mx_request_vars->request(POST_FORUM_URL, MX_TYPE_INT);
			}

			if ($mx_request_vars->is_request(POST_CAT_URL))
			{
				$cat_id = $mx_request_vars->request(POST_CAT_URL, MX_TYPE_INT);
			}

			if ($mx_request_vars->is_request('selected_id'))
			{
				$selected_id = $mx_request_vars->request('selected_id', MX_TYPE_NO_TAGS);
				$type = substr($selected_id, 0, 1);
				$id = intval(substr($selected_id, 1));
				if (!empty($id)) switch ($type)
				{
					case POST_CAT_URL:
						$cat_id = $id;
					break;
					case POST_FORUM_URL:
						$forum_id = $id;
					break;
					case POST_TOPIC_URL:
						$topic_id = $id;
					break;
					case POST_POST_URL:
						if ( !defined('IN_PRIVMSG') )
						{
							$post_id = $id;
					break;
						}
					default:
					break;
				}
			}

			// find the forum
			if ( ($forum_id <= 0) && ($cat_id <= 0) )
			{
				if ($post_id > 0)
				{
					$sql = "SELECT * FROM " . POSTS_TABLE . " WHERE post_id=$post_id";
					if ( !($result = $db->sql_query($sql)) )
					{
						mx_message_die(GENERAL_ERROR, 'Wasn\'t able to access posts', '', __LINE__, __FILE__, $sql);
					}
					if ( $row = $db->sql_fetchrow($result) )
					{
						$forum_id = $row['forum_id'];
					}
				}

				if ($topic_id > 0)
				{
					$sql = "SELECT * FROM " . TOPICS_TABLE . " WHERE topic_id=$topic_id";
					if ( !($result = $db->sql_query($sql)) )
					{
						mx_message_die(GENERAL_ERROR, 'Wasn\'t able to access topics', '', __LINE__, __FILE__, $sql);
					}
					if ( $row = $db->sql_fetchrow($result) )
					{
						$forum_id = $row['forum_id'];
					}
				}
			}

			// is the categories hierarchy v 2 installed ?
			$cat_hierarchy = function_exists('get_auth_keys');

			// get the ids (forums and cats)
			$fids = array();
			if (!$cat_hierarchy)
			{
				if ($forum_id > 0)
				{
					// add the forum_id
					$fids[] = POST_FORUM_URL . $forum_id;

					// get the cat_id
					$sql = "SELECT * FROM " . FORUMS_TABLE . " WHERE forum_id=$forum_id";
					if ( !($result = $db->sql_query($sql)) )
					{
						mx_message_die(GENERAL_ERROR, 'Wasn\'t able to access forums', '', __LINE__, __FILE__, $sql);
					}
					if ( $row = $db->sql_fetchrow($result) )
					{
						$cat_id = $row['cat_id'];
					}
				}

				// add the cat_id
				if ($cat_id > 0)
				{
					$fids[] = POST_CAT_URL . $cat_id;
				}

				// add the root level
				$fids[] = 'Root';
			}
			else
			{
				// categories hierarchy v 2 compliancy
				$cur = 'Root';
				if ($forum_id > 0)
				{
					$cur = POST_FORUM_URL . $forum_id;
				}
				else if ($cat_id > 0)
				{
					$cur = POST_CAT_URL . $cat_id;
				}

				// add start
				$fids[] = $cur;
				while ( ($cur != 'Root') && !empty($cur) )
				{
					// get parent level
					$cur = (isset($tree['main'][ $tree['keys'][$cur] ])) ? $tree['main'][ $tree['keys'][$cur] ] : 'Root';

					// add the parent level
					if ( !empty($cur) )
					{
						$fids[] = $cur;
					}
				}
			}

			// search if this file is part of a sub-template
			$sub_tpl_file = '';
			$sub_css_file = '';
			$sub_img_file = '';
			$sub_img_path = '';
			$template_path = $this->template_path;
			$template_name = substr( $this->root, strpos($this->root, $this->template_path) + strlen($this->template_path) );
			$real_root = $this->root;
			if ( $board_config['version'] > '.0.5' )
			{
				$real_root = mx_realpath($this->root);
			}
			if (substr($filename, 0, 1) != '/')
			{
				$found = false;
				$num_fids = count($fids);
				for ($i = 0; !$found && ($i < $num_fids); $i++)
				{
					$key = $fids[$i];

					// convert root into c0 category
					if ( ($key == 'Root') || empty($key) )
					{
						$key = POST_CAT_URL . '0';
					}

					if ( isset($sub_templates[$key]) )
					{
						// get the sub-template path
						$current_template_path = $this->template_path . $template_name . '/' . $sub_templates[$key]['dir'];
						$root_template_path = $real_root . '/' . $sub_templates[$key]['dir'];

						// set the filename
						if ( empty($sub_tpl_file) && file_exists($root_template_path . '/' . $filename) )
						{
							$found = true;
							$sub_tpl_file = $sub_templates[$key]['dir'] . '/' . $filename;
							break;
						}
					}
				}

				// set the css file name
				$found = false;
				$num_fids = count($fids);
				for ($i = 0; !$found && ($i < $num_fids); $i++)
				{
					$key = $fids[$i];

					// convert root into c0 category
					if ( ($key == 'Root') || empty($key) )
					{
						$key = POST_CAT_URL . '0';
					}

					if ( isset($sub_templates[$key]) )
					{
						// get the sub-template path
						$current_template_path = $this->template_path . $template_name . '/' . $sub_templates[$key]['dir'];
						$root_template_path = $real_root . '/' . $sub_templates[$key]['dir'];
						if ( empty($sub_css_file) && isset($sub_templates[$key]['head_stylesheet']) && file_exists($root_template_path . '/' . $sub_templates[$key]['head_stylesheet']) )
						{
							$found = true;
							$sub_css_file = $sub_templates[$key]['dir'] . '/' . $sub_templates[$key]['head_stylesheet'];
							break;
						}
					}
				}

				// set the img file name
				$found = false;
				$num_fids = count($fids);
				for ($i = 0; !$found && ($i < $num_fids); $i++)
				{
					$key = $fids[$i];

					// convert root into c0 category
					if ( ($key == 'Root') || empty($key) )
					{
						$key = POST_CAT_URL . '0';
					}

					if ( isset($sub_templates[$key]) )
					{
						// get the sub-template path
						$current_template_path = $this->template_path . $template_name . '/' . $sub_templates[$key]['dir'];
						$root_template_path = $real_root . '/' . $sub_templates[$key]['dir'];
						if ( isset($sub_templates[$key]['imagefile']) && file_exists($root_template_path . '/' . $sub_templates[$key]['imagefile']) )
						{
							$sub_img_path = $sub_templates[$key]['dir'];
							$sub_img_file = $sub_templates[$key]['imagefile'];

							// send back the lowest level of the images file
							$found = true;
							$sub_template_key_image = $key;
							break;
						}
					}
				}
			}

			// set the tpl file
			if ( !empty($sub_tpl_file) )
			{
				$filename = $sub_tpl_file;
			}

			// set the css file
			if ( !empty($sub_css_file) )
			{
				$theme['head_stylesheet'] = $sub_css_file;
			}

			// get the root level images
			$key = POST_CAT_URL . '0';
			if ( isset($sub_templates[$key]) )
			{
				// get the sub-template path
				$current_template_path = $this->template_path . $template_name . '/' . $sub_templates[$key]['dir'];
				$root_template_path = $real_root . '/' . $sub_templates[$key]['dir'];
				if ( isset($sub_templates[$key]['imagefile']) && file_exists($root_template_path . '/' . $sub_templates[$key]['imagefile']) )
				{
					$sav_images = $images;
					$images = array();
					@include($root_template_path . '/' . $sub_templates[$key]['imagefile']);
					$img_lang = ( file_exists($root_template_path . '/images/lang_' . $board_config['default_lang']) ) ? $board_config['default_lang'] : 'english';
					foreach($images as $key => $value)
					{
						if ( !is_array($value) )
						{
							$images[$key] = str_replace('{LANG}', 'lang_' . $img_lang, $value);
						}
						$sav_images[$key] = $images[$key];
					}
					$images = $sav_images;
					$sav_images = array();
				}
			}

			// get the current images
			if ( !empty($sub_template_key_image) && ($sub_template_key_image != POST_CAT_URL . '0') )
			{
				$key = $sub_template_key_image;

				// get the sub-template path
				$current_template_path = $this->template_path . $template_name . '/' . $sub_templates[$key]['dir'];
				$root_template_path = $real_root . '/' . $sub_templates[$key]['dir'];
				if ( isset($sub_templates[$key]['imagefile']) && file_exists($root_template_path . '/' . $sub_templates[$key]['imagefile']) )
				{
					$sav_images = $images;
					$images = array();
					@include($root_template_path . '/' . $sub_templates[$key]['imagefile']);
					$img_lang = ( file_exists($root_template_path . '/images/lang_' . $board_config['default_lang']) ) ? $board_config['default_lang'] : 'english';
					foreach($images as $key => $value)
					{
						if ( !is_array($value) )
						{
							$images[$key] = str_replace('{LANG}', 'lang_' . $img_lang, $value);
						}
						$sav_images[$key] = $images[$key];
					}
					$images = $sav_images;
					$sav_images = array();
				}
			}
		}
		return $filename;
	}

	/**
	 * Generates a full path+filename for the given filename, which can either
	 * be an absolute name, or a name relative to the rootdir for this Template
	 * object.
	 */
	function make_filename($filename, $xs_include = false)
	{
		if($this->subtemplates)
		{
			$filename = $this->subtemplates_make_filename($filename);
		}
		// Check replacements list
		if(!$xs_include && isset($this->replace[$filename]))
		{
			$filename = $this->replace[$filename];
		}
		// Check if it's an absolute or relative path.
		if ((substr($filename, 0, 1) !== '/') && (substr($filename, 1, 1) !== ':'))
		{
       		return $this->root . '/' . $filename;
		}
		else
		{
			return str_replace('\\', '/', $filename);
		}
	}

	/**
	 * Converts template filename to cache filename.
	 * Returns empty string if non-cachable (for tpl files outside of root dir).
	 * $file should be absolute filename
	 */
	function make_filename_cache($file)
	{
		$phpEx = 'php';
		$str = str_replace($this->cache_search, $this->cache_replace, $file);
		if(substr($file, 0, $this->tpldir_len) !== $this->tpldir || empty($this->tpl))
		{
			return $this->cachedir . XS_TPL_PREFIX2 . $str .'.'. $phpEx;
		}
		// removing not needed part
		$file = substr($file, $this->tpldir_len, strlen($file)) .'.'. $phpEx;
		// creating filename
		return $this->cachedir . XS_TPL_PREFIX . str_replace($this->cache_search, $this->cache_replace, $file) .'.'. $phpEx;
	}
	
	/**
	* Set template location
	* @access public
	*/
	function set_template()
	{
		global $phpbb_root_path, $mx_root_path, $mx_user;

		if (file_exists($mx_root_path . XS_TPL_START . $mx_user->theme['template_path'] . '/template'))
		{
			$this->root = $mx_root_path . XS_TPL_START . $mx_user->theme['template_path'] . '/template';
			$this->cachepath = $mx_root_path . 'cache/tpl_' . str_replace('_', '-', $mx_user->theme['template_path']) . '_';

			if ($this->orig_tpl_storedb === null)
			{
				$this->orig_tpl_storedb = $mx_user->theme['template_storedb'];
			}

			if ($this->orig_tpl_inherits_id === null)
			{
				$this->orig_tpl_inherits_id = $mx_user->theme['template_inherits_id'];
			}

			$mx_user->theme['template_storedb'] = $this->orig_tpl_storedb;
			$mx_user->theme['template_inherits_id'] = $this->orig_tpl_inherits_id;

			if ($mx_user->theme['template_inherits_id'])
			{
				$this->inherit_root = $mx_root_path . XS_TPL_START . $mx_user->theme['template_inherit_path'] . '/template';
			}
		}
		elseif (file_exists($phpbb_root_path . XS_TPL_START . $mx_user->theme['template_path'] . '/template'))
		{
			$this->root = $phpbb_root_path . XS_TPL_START . $mx_user->theme['template_path'] . '/template';
			$this->cachepath = $phpbb_root_path . 'cache/tpl_' . str_replace('_', '-', $mx_user->theme['template_path']) . '_';

			if ($this->orig_tpl_storedb === null)
			{
				$this->orig_tpl_storedb = $mx_user->theme['template_storedb'];
			}

			if ($this->orig_tpl_inherits_id === null)
			{
				$this->orig_tpl_inherits_id = $mx_user->theme['template_inherits_id'];
			}

			$mx_user->theme['template_storedb'] = $this->orig_tpl_storedb;
			$mx_user->theme['template_inherits_id'] = $this->orig_tpl_inherits_id;

			if ($mx_user->theme['template_inherits_id'])
			{
				$this->inherit_root = $mx_root_path . XS_TPL_START . $mx_user->theme['template_inherit_path'] . '/template';
			}
		}		
		else
		{
			trigger_error('Template path could not be found: ' . XS_TPL_START . $mx_user->theme['template_path'] . '/template', E_USER_ERROR);
		}
		//$this->vars = &$this->tpldata['.'][0];
		$this->vars = &$this->_tpldata['.'][0];
		$this->_rootref = &$this->_tpldata['.'][0];
		//$this->rootref = &$this->tpldata['.'][0];
		return true;
	}
	
	/**
	* Set custom template location (able to use directory outside of phpBB)
	* @access public
	*/
	function set_custom_template($template_path, $template_name, $fallback_template_path = false)
	{
		global $mx_root_path, $mx_user;

		// Make sure $template_path has no ending slash
		if (substr($template_path, -1) == '/')
		{
			$template_path = substr($template_path, 0, -1);
		}

		$this->root = $template_path;
		$this->cachepath = $mx_root_path . 'cache/ctpl_' . str_replace('_', '-', $template_name) . '_';

		if ($fallback_template_path !== false)
		{
			if (substr($fallback_template_path, -1) == '/')
			{
				$fallback_template_path = substr($fallback_template_path, 0, -1);
			}

			$this->inherit_root = $fallback_template_path;
			$this->orig_tpl_inherits_id = true;
		}
		else
		{
			$this->orig_tpl_inherits_id = false;
		}

		// the database does not store the path or name of a custom template
		// so there is no way we can properly store custom templates there
		$this->orig_tpl_storedb = false;
		$this->vars = &$this->_tpldata['.'][0];
		$this->_rootref = &$this->_tpldata['.'][0];

		return true;
	}
	
	/**
	* Sets the template filenames for handles. $filename_array
	* should be a hash of handle => filename pairs.
	* @access public
	*/
	function set_filenames($filename_array)
	{
		if (!is_array($filename_array))
		{
			return false;
		}
		
		foreach ($filename_array as $handle => $filename)
		{
			if (empty($filename))
			{
				
				trigger_error("template->set_filenames: Empty filename specified for $handle", E_USER_ERROR);
			}		
			
			/** */
			$this->filename[$handle] = $filename;
			$this->files[$handle] = $this->root . '/' . $filename;
			/** */
			$res = $this->set_filename($handle, $filename);
			/** */
			if ($this->inherit_root)
			{
				$this->files_inherit[$handle] = $this->inherit_root . '/' . $filename;
			}
			/** */
		}

		return true;
	}
	
	/**
	* Get a filename from the handle
	*
	* @param string $handle
	* @return string
	*/
	protected function get_filename_from_handle($handle)
	{
		return (isset($this->filenames[$handle])) ? $this->filenames[$handle] : $handle;
	}
	
	/**
	 * Assigns template filename for handle.
	 */
	function set_filename($handle, $filename, $xs_include = false, $quiet = false)
	{
		global $board_config, $module_root_path, $mx_root_path, $phpbb_root_path, $theme, $mx_user, $mx_block;
		$can_cache = $this->use_cache;
		if(strpos($filename, '..') !== false)
		{
			$can_cache = false;
		}
		$this->files[$handle] = $this->make_filename($filename, $xs_include);
		$this->files_cache[$handle] = '';
		$this->files_cache2[$handle] = '';
		// check if we are in admin control panel and override extreme styles mod controls if needed
		if(defined('XS_ADMIN_OVERRIDE') && XS_ADMIN_OVERRIDE === true && @function_exists('xs_admin_override'))
		{
			xs_admin_override();
		}
		// checking if we have valid filename
		if(!$this->files[$handle])
		{
			if($xs_include || $quiet)
			{
				return false;
			}
			else
			{
				die("Template->make_filename(): Error - invalid template $filename");
			}
		}

		// creating cache filename
		if(!empty($can_cache))
		{
			$this->files_cache2[$handle] = $this->make_filename_cache($this->files[$handle]);
			if(@file_exists($this->files_cache2[$handle]))
			{
				$this->files_cache[$handle] = $this->files_cache2[$handle];
			}
		}
		// checking if tpl and/or php file exists
		if(empty($this->files_cache[$handle]) && !@file_exists($this->files[$handle]))
		{
			// trying to load alternative filename (usually subSilver)
			if(!empty($this->tpldef) && !empty($this->tpl) && ($this->tpldef !== $this->tpl))
			{
				$this->files[$handle] = '';
				// save old configuration
				$root = $this->root;
				$tpl_name = $this->tpl;
				// set temporary configuration
				$this->root = $this->tpldir . $this->tpldef;
				$this->tpl = $this->tpldef;
				// recursively run set_filename
				$res = $this->set_filename($handle, $filename, $xs_include, $quiet);
				// restore old configuration
				$this->root = $root;
				$this->tpl = $tpl_name;
				return $res;
			}
			if($quiet)
			{
				return false;
			}
			if($xs_include)
			{
				if($board_config['xs_warn_includes'])
				{
					die('Template->make_filename(): Error - included template file not found: ' . $filename);
				}
				return false;
			}
			else
			{
				die('Template->make_filename(): Error - template file not found: ' . $filename);
			}
		}
		// checking if we should recompile cache
		if(!empty($this->files_cache[$handle]) && !empty($board_config['xs_auto_recompile']))
		{
			$cache_time = @filemtime($this->files_cache[$handle]);
			if(@filemtime($this->files[$handle]) > $cache_time || $board_config['xs_template_time'] > $cache_time)
			{
				// file was changed. don't use cache file (will be recompled if configuration allowes it)
				$this->files_cache[$handle] = '';
			}
		}
		return true;
	}

	/**
	 * includes file or executes code
	 */
	function execute($filename, $code, $handle, $include_once = false)
	{
		global $lang, $theme, $board_config, $mx_user;
		global $admin_script;

		//
		// Note: This little snippet is needed to make the templating work with Olympus
		//
		if (!defined('IN_ADMIN'))
		{
			$admin_script = ($admin_script) ? $admin_script : $filename;
		}		

		//if ( !(PORTAL_BACKEND == 'phpbb3') )
		//{
		//	$template = $theme['template_name'];
		//}
		//else
		//{
		//	$template = $theme['style_name'];
		//}

		$template = $mx_user->template_name;

		global $$template;
		$theme_info = &$$template;
		if($board_config['xs_add_comments'] && $handle)
		{
			echo '<!-- template ', $this->files[$handle], ' start -->';
		}			
		//inlcude_once()  only includes one block per module
		if ($filename)
		{
			($include_once) ? @include_once($filename) : @require($filename);
		}
		elseif ($admin_script)
		{
			($include_once) ? @include_once($admin_script) : @require($admin_script); // See note above
		}
		else
		{
			@eval($code);
		}

		if($board_config['xs_add_comments'] && $handle)
		{
			echo '<!-- template ', $this->files[$handle], ' end -->';
		}
		return true;
	}
	
	/**
	* Extra CSS and JS
	*/
	function add_css_js()
	{
		if (!defined('CSS_JS_PARSED'))
		{
			define('CSS_JS_PARSED', true);
		}

		// Include custom CSS from templates/CURRENT_TPL folder
		if(is_array($this->css_style_include) && !empty($this->css_style_include))
		{
			for ($i = 0; $i < sizeof($this->css_style_include); $i++)
			{
				$this->assign_block_vars('css_style_include', array(
					'CSS_FILE' => $this->css_style_include[$i],
					)
				);
			}
		}

		// Include custom CSS from templates/common folder
		if(is_array($this->css_include) && !empty($this->css_include))
		{
			for ($i = 0; $i < sizeof($this->css_include); $i++)
			{
				$this->assign_block_vars('css_include', array(
					'CSS_FILE' => $this->css_include[$i],
					)
				);
			}
		}

		// Include custom JS from templates/common folder
		if(is_array($this->js_include) && !empty($this->js_include))
		{
			for ($i = 0; $i < sizeof($this->js_include); $i++)
			{
				$this->assign_block_vars('js_include', array(
					'JS_FILE' => $this->js_include[$i],
					)
				);
			}
		}
	}
	
	/**
	 * Load the file for the handle, compile the file,
	 * and run the compiled code. This will print out
	 * the results of executing the template.
	 */
	function pparse($handle)
	{
		global $board_config;
		
		// Mighty Gorgon - Extra Debug - BEGIN
		if (defined('DEBUG_EXTRA') && !empty($_REQUEST['explain']))
		{
			global $mx_user, $db;
			if (($mx_user->data['user_level'] == ADMIN) && method_exists($db, 'sql_report'))
			{
				return false;
			}
		}
		// Mighty Gorgon - Extra Debug - END

		if (!defined('CSS_JS_PARSED'))
		{
			$this->add_css_js();
		}		
		
		// parsing header if there is one
		if($this->preparse || $this->postparse)
		{
			$preparse = $this->preparse;
			$postparse = $this->postparse;
			$this->preparse = '';
			$this->postparse = '';
			if($preparse)
			{
				$this->pparse($preparse);
			}
			if($postparse)
			{
				$str = $handle;
				$handle = $postparse;
				$this->pparse($str);
			}
		}
		// checking if handle exists
		if (empty($this->files[$handle]) && empty($this->files_cache[$handle]))
		{
			die("Template->loadfile(): No files found for handle $handle");
		}
		$this->xs_startup();
		$force_recompile = empty($this->uncompiled_code[$handle]) ? false : true;
		// checking if php file exists.
		if (!empty($this->files_cache[$handle]) && !$force_recompile)
		{
			// php file exists - running it instead of tpl
			$this->execute($this->files_cache[$handle], '', $handle);
			return true;
		}
		if (!$this->loadfile($handle))
		{
			die("Template->pparse(): Couldn't load template file for handle $handle");
		}
		// actually compile the template now.
		if (empty($this->compiled_code[$handle]))
		{
			// Actually compile the code now.
			if(!empty($this->files_cache2[$handle]) && empty($this->files_cache[$handle]) && !$force_recompile)
			{
				$this->compiled_code[$handle] = $this->compile2($this->uncompiled_code[$handle], $handle, $this->files_cache2[$handle]);
			}
			else
			{
				$this->compiled_code[$handle] = $this->compile2($this->uncompiled_code[$handle], '', '');
			}
		}
		// Run the compiled code.
		if (empty($this->files_cache[$handle]) || $force_recompile)
		{
			$this->execute('', $this->compiled_code[$handle], $handle);
		}
		else
		{
			$this->execute($this->files_cache[$handle], '', $handle);
		}
		return true;
	}


	/**
	* Load a compiled template if possible, if not, recompile it
	* @access private
	*/
	function _tpl_load(&$handle)
	{
		global $mx_user, $phpEx, $board_config;

		$recompile = (($board_config['load_tplcompile'] && @filemtime($filename) < filemtime($this->files[$handle])) || !file_exists($filename) || @filesize($filename) === 0) ? true : false;

		// Recompile page if the original template is newer, otherwise load the compiled version
		if (!$recompile)
		{
			return $filename;
		}

		// Just compile if no user object is present (happens within the installer)
		$this->loadfile($handle);
		return false;
	}

	/**
	* Display handle
	* @access public
	*/
	function display($handle, $include_once = true)
	{
		global $mx_user, $phpbb_hook;

		if (!empty($phpbb_hook) && $phpbb_hook->call_hook(array(__CLASS__, __FUNCTION__), $handle, $include_once))
		{
			if ($phpbb_hook->hook_return(array(__CLASS__, __FUNCTION__)))
			{
				return $phpbb_hook->hook_return_result(array(__CLASS__, __FUNCTION__));
			}
		}

		if (defined('IN_ERROR_HANDLER'))
		{
			if ((E_NOTICE & error_reporting()) == E_NOTICE)
			{
				error_reporting(error_reporting() ^ E_NOTICE);
			}
		}
		

		//if ($filename = $this->_tpl_load($handle))
		if ($filename)
		{
			($include_once) ? include_once($filename) : include($filename);
		}
		else
		{
			eval(' ?>' . $this->compiled_code[$handle] . '<?php ');
		}

		return true;
	}

	/**
	* Display the handle and assign the output to a template variable or return the compiled result.
	* @access public
	*/
	function assign_display($handle, $template_var = '', $return_content = true, $include_once = false)
	{
		ob_start();
		$this->display($handle, $include_once);
		$contents = ob_get_clean();

		if ($return_content)
		{
			return $contents;
		}

		$this->assign_var($template_var, $contents);

		return true;
	}

	/**
	 * Precompile file
	 */
	function precompile($template, $filename)
	{
		global $precompile_num, $board_config;
		if(empty($precompile_num))
		{
			$precompile_num = 0;
		}
		$precompile_num ++;
		$handle = 'precompile_' . $precompile_num;
		// save old configuration
		$root = $this->root;
		$tpl_name = $this->tpl;
		$old_config = $this->use_cache;
		$old_autosave = $this->auto_compile;
		// set temporary configuration
		$this->root = $this->tpldir . $template;
		$this->tpl = $template;
		$this->use_cache = 1;
		$this->auto_compile = 1;
		// set filename
		$res = $this->set_filename($handle, $filename, true, true);
		if(!$res || !$this->files_cache2[$handle])
		{
			$this->root = $root;
			$this->tpl = $tpl_name;
			$this->use_cache = $old_config;
			$this->auto_compile = $old_autosave;
			return false;
		}
		$this->files_cache[$handle] = '';
		// load template
		$res = $this->loadfile($handle);
		if(!$res || empty($this->uncompiled_code[$handle]))
		{
			$this->root = $root;
			$this->tpl = $tpl_name;
			$this->use_cache = $old_config;
			$this->auto_compile = $old_autosave;
			return false;
		}
		// compile the code
		$this->compile2($this->uncompiled_code[$handle], $handle, $this->files_cache2[$handle]);
		// restore confirugation
		$this->root = $root;
		$this->tpl = $tpl_name;
		$this->use_cache = $old_config;
		$this->auto_compile = $old_autosave;
		return true;
	}

	/**
	 * Inserts the uncompiled code for $handle as the
	 * value of $varname in the root-level. This can be used
	 * to effectively include a template in the middle of another
	 * template.
	 * Note that all desired assignments to the variables in $handle should be done
	 * BEFORE calling this function.
	 */
	function assign_var_from_handle($varname, $handle)
	{
		ob_start();
		$res = $this->pparse($handle);
		$this->vars[$varname] = ob_get_contents();
		ob_end_clean();
		return $res;
	}

	/**
	* Assign key variable pairs from an array to a specified block
	*
	* @param string $blockname Name of block to assign $vararray to
	* @param array $vararray A hash of variable name => value pairs
	* @return true
	*/
	public function assign_block_vars($blockname, array $vararray)
	{
		$this->num_rows_is_set = false;
		if (strstr($blockname, '.'))
		{
			// For nested block, $blockcount > 0, for top-level block, $blockcount == 0
			$blocks = explode('.', $blockname);
			$blockcount = count($blocks) - 1;
			$str = &$this->_tpldata;
			$block = &$this->tpldata;
			for ($i = 0; $i < $blockcount; $i++)
			{
				$pos = strpos($blocks[$i], '[');
				$name = ($pos !== false) ? substr($blocks[$i], 0, $pos) : $blocks[$i];
				$block = &$block[$name];
				$index = (!$pos || strpos($blocks[$i], '[]') === $pos) ? (count($block) - 1) : (min((int) substr($blocks[$i], $pos + 1, -1), count($block) - 1));
				$block = &$block[$index];
				
				$str = &$str[$blocks[$i].'.'];
								
				$str = &$str[sizeof($str)-1]; 				
			}

			// $block = &$block[$blocks[$i]]; // Do not traverse the last block as it might be empty
			$name = $blocks[$i];

			// Assign S_ROW_COUNT and S_ROW_NUM
			$s_row_count = isset($block[$name]) ? count($block[$name]) : 0;
			$vararray['S_ROW_COUNT'] = $vararray['S_ROW_NUM'] = $s_row_count;

			// Assign S_FIRST_ROW
			if (!$s_row_count)
			{
				$vararray['S_FIRST_ROW'] = true;
			}

			// Assign S_BLOCK_NAME
			$vararray['S_BLOCK_NAME'] = $name;

			// Now the tricky part, we always assign S_LAST_ROW and remove the entry before
			// This is much more clever than going through the complete template data on display (phew)
			$vararray['S_LAST_ROW'] = true;
			if ($s_row_count > 0)
			{
				unset($block[$name][($s_row_count - 1)]['S_LAST_ROW']);
			}

			// Now we add the block that we're actually assigning to.
			// We're adding a new iteration to this block with the given
			// variable assignments.
			$block[$name][] = $vararray;
			$str[$blocks[$blockcount].'.'][] = $vararray;
		}
		else
		{
			// Top-level block.
			$s_row_count = (isset($this->_tpldata[$blockname])) ? sizeof($this->_tpldata[$blockname]) : 0;
			// T$s_row_count = (isset($this->tpldata[$blockname])) ? sizeof($this->tpldata[$blockname]) : 0;			
			$vararray['S_ROW_COUNT'] = $s_row_count;

			// Assign S_FIRST_ROW
			if (!$s_row_count)
			{
				$vararray['S_FIRST_ROW'] = true;
			}

			// We always assign S_LAST_ROW and remove the entry before
			$vararray['S_LAST_ROW'] = true;
			if ($s_row_count > 0)
			{
				unset($this->_tpldata[$blockname][($s_row_count - 1)]['S_LAST_ROW']);
			}			
			
			// Add a new iteration to this block with the variable assignments
			// we were given.
			$this->_tpldata[$blockname.'.'][] = $vararray;
			//$this->tpldata[$blockname.'.'][] = $vararray;		
			// Add a new iteration to this block with the variable assignments we were given.			
		}

		return true;
	}
	
	/**
	* Assign key variable pairs from an array to a whole specified block loop
	*
	* @param string $blockname Name of block to assign $block_vars_array to
	* @param array $block_vars_array An array of hashes of variable name => value pairs
	* @return true
	*/
	public function assign_block_vars_array($blockname, array $block_vars_array)
	{
		foreach ($block_vars_array as $vararray)
		{
			$this->assign_block_vars($blockname, $vararray);
		}

		return true;
	}
	
	/**
	 * Root-level variable assignment. Adds to current assignments, overriding
	 * any existing variable assignment with the same name.
	 */
	function assign_vars($vararray)
	{
		foreach($vararray as $key => $val)
		{
			$this->vars[$key] = $val;
			//$this->_rootref[$key] = $val;			
		}
		return true;
	}

	/**
	 * Root-level variable assignment. Adds to current assignments, overriding
	 * any existing variable assignment with the same name.
	 */
	function assign_var($varname, $varval)
	{
		$this->vars[$varname] = $varval;
		//$this->_rootref[$varname] = $varval;		
		
		return true;
	}
	
	/**
	* Returns a reference to template data array.
	*
	* This function is public so that template renderer may invoke it.
	* Users should alter template variables via functions in \phpbb\template\template.
	*
	* Note: modifying returned array will affect data stored in the context.
	*
	* @return array template data
	*/
	function &get_data_ref()
	{
		// returning a reference directly is not
		// something php is capable of doing
		$ref = &$this->tpldata;

		if (!$this->num_rows_is_set)
		{
			/*
			* We do not set S_NUM_ROWS while adding a row, to reduce the complexity
			* If we would set it on adding, each subsequent adding would cause
			* n modifications, resulting in a O(n!) complexity, rather then O(n)
			*/
			foreach ($ref as $loop_name => &$loop_data)
			{
				if ($loop_name === '.')
				{
					continue;
				}

				$this->set_num_rows($loop_data);
			}
			$this->num_rows_is_set = true;
		}

		return $ref;
	} 
	
	/**
	* Set S_NUM_ROWS for each row in this template block
	*
	* @param array $loop_data
	*/
	protected function set_num_rows(&$loop_data)
	{
		$s_num_rows = sizeof($loop_data);
		foreach ($loop_data as &$mod_block)
		{
			foreach ($mod_block as $sub_block_name => &$sub_block)
			{
				// If the key name is lowercase and the data is an array,
				// it could be a template loop. So we set the S_NUM_ROWS there
				// aswell.
				if ($sub_block_name === strtolower($sub_block_name) && is_array($sub_block))
				{
					$this->set_num_rows($sub_block);
				}
			}

			// Check whether we are inside a block before setting the variable
			if (isset($mod_block['S_BLOCK_NAME']))
			{
				$mod_block['S_NUM_ROWS'] = $s_num_rows;
			}
		}
	}

	/**
	* Returns a reference to template root scope.
	*
	* This function is public so that template renderer may invoke it.
	* Users should not need to invoke this function.
	*
	* Note: modifying returned array will affect data stored in the context.
	*
	* @return array template data
	*/
	public function &get_root_ref()
	{
		// rootref is already a reference
		return $this->rootref;
	}	
	
	/**
	 * If not already done, load the file for the given handle and populate
	 * the uncompiled_code[] hash with its code. Do not compile.
	 */
	function loadfile($handle)
	{
		global $board_config;
		// If cached file exists do nothing - it will be included via include()
		if(!empty($this->files_cache[$handle]))
		{
			return true;
		}

		// If the file for this handle is already loaded and compiled, do nothing.
		if (!empty($this->uncompiled_code[$handle]))
		{
			return true;
		}

		// If we don't have a file assigned to this handle, die.
		if (empty($this->files[$handle]))
		{
			die("Template->loadfile(): No file specified for handle $handle");
		}
		
		// Don't chmod links as mostly those require 0777 and that cannot be changed
		if (is_file($this->files[$handle]))
		{
			$filename = $this->files[$handle];
			$str = @implode('', file($filename));
		}		
		else if (is_dir($this->files[$handle]) || (is_link($this->files[$handle])))
		{
			$filename = $this->files[$handle] . 'index.htm';
			$str = '';
		}
					
		if (empty($str))
		{
			die("Template->loadfile(): File $filename for handle $handle is empty");
		}

		$this->uncompiled_code[$handle] = $str;

		return true;
	}



	/**
	 * Generates a reference to the given variable inside the given (possibly nested)
	 * block namespace. This is a string of the form:
	 * ' . $this->_tpldata['parent.'][$_parent_i]['$child1.'][$_child1_i]['$child2.'][$_child2_i]...['varname'] . '
	 * It's ready to be inserted into an "echo" line in one of the templates.
	 * NOTE: expects a trailing "." on the namespace.
	 */
	function generate_block_varref($namespace, $varname, $use_isset = true)
	{
		// Strip the trailing period.
		$namespace = substr($namespace, 0, strlen($namespace) - 1);

		// Get a reference to the data block for this namespace.
		$varref = $this->generate_block_data_ref($namespace, true);
		// Prepend the necessary code to stick this in an echo line.

		// Append the variable reference.
		$varref .= '[\'' . $varname . '\']';

		if($use_isset)
		{
			$varref = '<'.'?php echo isset(' . $varref . ') ? ' . $varref . ' : \'\'; ?'.'>';
		}
		else
		{
			$varref = '<'.'?php echo ' . $varref . '; ?'.'>';
		}

		return $varref;

	}


	/**
	 * Generates a reference to the array of data values for the given
	 * (possibly nested) block namespace. This is a string of the form:
	 * $this->_tpldata['parent.'][$_parent_i]['$child1.'][$_child1_i]['$child2.'][$_child2_i]...['$childN.']
	 *
	 * If $include_last_iterator is true, then [$_childN_i] will be appended to the form shown above.
	 * NOTE: does not expect a trailing "." on the blockname.
	 */
	function generate_block_data_ref($blockname, $include_last_iterator, $defop = false)
	{
		$blockname = !empty($blockname) ? $blockname : 'parent';
		// Get an array of the blocks involved.
		$blocks = explode('.', $blockname);
		$blockcount = sizeof($blocks) - 1;
		if($defop)
		{
			$varref = '$this->_tpldata[\'DEFINE\']';
			// Build up the string with everything but the last child.
			for ($i = 0; $i < $blockcount; $i++)
			{
				$varref .= "['" . $blocks[$i] . ".'][\$" . $blocks[$i] . '_i]';
			}
			// Add the block reference for the last child.
			$varref .= "['" . $blocks[$blockcount] . ".']";
			// Add the iterator for the last child if requried.
			if ($include_last_iterator)
			{
				$varref .= '[$' . $blocks[$blockcount] . '_i]';
			}
			return $varref;
		}
		if($include_last_iterator)
		{
			return '$'. $blocks[$blockcount]. '_item';
		}
		else
		{
			return '$'. $blocks[$blockcount-1]. '_item[\''. $blocks[$blockcount]. '.\']';
		}
	}
	
	/**
	* Remove any PHP tags that do not belong, these regular expressions are derived from
	* the ones that exist in zend_language_scanner.l
	* @access private
	*/
	function remove_php_tags(&$code)
	{
		// This matches the information gathered from the internal PHP lexer
		$match = array(
			'#<([\?%])=?.*?\1>#s',
			'#<script\s+language\s*=\s*(["\']?)php\1\s*>.*?</script\s*>#s',
			'#<\?php(?:\r\n?|[ \n\t]).*?\?>#s'
		);

		$code = preg_replace($match, '', $code);
	}
	
	/**
	* Compile blocks
	* @access private
	*/
	function compile_tag_block($tag_args)
	{
		$no_nesting = false;

		// Is the designer wanting to call another loop in a loop?
		if (strpos($tag_args, '!') === 0)
		{
			// Count the number of ! occurrences (not allowed in vars)
			$no_nesting = substr_count($tag_args, '!');
			$tag_args = substr($tag_args, $no_nesting);
		}

		// Allow for control of looping (indexes start from zero):
		// foo(2)    : Will start the loop on the 3rd entry
		// foo(-2)   : Will start the loop two entries from the end
		// foo(3,4)  : Will start the loop on the fourth entry and end it on the fifth
		// foo(3,-4) : Will start the loop on the fourth entry and end it four from last
		if (preg_match('#^([^()]*)\(([\-\d]+)(?:,([\-\d]+))?\)$#', $tag_args, $match))
		{
			$tag_args = $match[1];

			if ($match[2] < 0)
			{
				$loop_start = '($_' . $tag_args . '_count ' . $match[2] . ' < 0 ? 0 : $_' . $tag_args . '_count ' . $match[2] . ')';
			}
			else
			{
				$loop_start = '($_' . $tag_args . '_count < ' . $match[2] . ' ? $_' . $tag_args . '_count : ' . $match[2] . ')';
			}

			if (strlen($match[3]) < 1 || $match[3] == -1)
			{
				$loop_end = '$_' . $tag_args . '_count';
			}
			else if ($match[3] >= 0)
			{
				$loop_end = '(' . ($match[3] + 1) . ' > $_' . $tag_args . '_count ? $_' . $tag_args . '_count : ' . ($match[3] + 1) . ')';
			}
			else //if ($match[3] < -1)
			{
				$loop_end = '$_' . $tag_args . '_count' . ($match[3] + 1);
			}
		}
		else
		{
			$loop_start = 0;
			$loop_end = '$_' . $tag_args . '_count';
		}

		$tag_template_php = '';
		
		/**
		* Minimum Requirement: PHP 5.4.0 for phpBB3
		*/
		if (version_compare(PHP_VERSION_MX, '5.4') > 0)
		{
			//array_push(is_array($this->block_names) ? $this->block_names : array($this->block_names), $tag_args);
			array_push($this->block_names, $tag_args);
		}		
		elseif (version_compare(PHP_VERSION, '5.6') < 0)
		{
			array_push($this->block_names, $tag_args);
		}			
		else
		{				
			//array_push(is_array($this->block_names) ? $this->block_names : array($this->block_names), $tag_args);
			array_push($this->block_names, $tag_args);
		}
		
		if ($no_nesting !== false)
		{
			// We need to implode $no_nesting times from the end...
			$block = array_slice($this->block_names, -$no_nesting);
		}
		else
		{
			$block = $this->block_names;
		}

		if (sizeof($block) < 2)
		{
			// Block is not nested.
			$tag_template_php = '$_' . $tag_args . "_count = (isset(\$this->_tpldata['$tag_args'])) ? sizeof(\$this->_tpldata['$tag_args']) : 0;";
			$varref = "\$this->_tpldata['$tag_args']";
			//$varref = $this->_tpldata[$tag_args];			
		}
		else
		{
			// This block is nested.
			// Generate a namespace string for this block.
			$namespace = implode('.', $block);

			// Get a reference to the data array for this block that depends on the
			// current indices of all parent blocks.
			$varref = $this->generate_block_data_ref($namespace, false);

			// Create the for loop code to iterate over this block.
			$tag_template_php = '$_' . $tag_args . '_count = (isset(' . $varref . ')) ? sizeof(' . $varref . ') : 0;';
		}

		$tag_template_php .= 'if ($_' . $tag_args . '_count) {';

		/**
		* The following uses foreach for iteration instead of a for loop, foreach is faster but requires PHP to make a copy of the contents of the array which uses more memory
		* <code>
		*	if (!$offset)
		*	{
		*		$tag_template_php .= 'foreach (' . $varref . ' as $_' . $tag_args . '_i => $_' . $tag_args . '_val){';
		*	}
		* </code>
		*/

		$tag_template_php .= 'for ($_' . $tag_args . '_i = ' . $loop_start . '; $_' . $tag_args . '_i < ' . $loop_end . '; ++$_' . $tag_args . '_i){';
		$tag_template_php .= '$_'. $tag_args . '_val = &' . $varref . '[$_'. $tag_args. '_i];';

		return $tag_template_php;
	}

	/**
	* Compile INCLUDE tag
	* @access private
	*/
	function compile_tag_include($tag_args)
	{
		// Process dynamic includes
		if ($tag_args[0] == '$')
		{
			return "if (isset($tag_args)) { \$this->_tpl_include($tag_args); }";
		}

		return "\$this->_tpl_include('$tag_args');";
	}

	/**
	* Compile INCLUDE_PHP tag
	* @access private
	*/
	function compile_tag_include_php($tag_args)
	{
		return "\$this->_php_include('$tag_args');";
	}

	function compile_code2($filename, $code, $use_isset = false)
	{
		//	$filename - file to load code from. used if $code is empty
		//	$code - tpl code
		//	$use_isset - if false then compiled code looks more beautiful and easier
		//      to understand and it adds error_reporting() to supress php warnings.
		//      if true then isset() is used to check variables instead of supressing
		//	    php warnings. note: for extreme styles mod 2.x it works only for
		//		block variables and for usual variables its always true.

		// load code from file
		if(!$code && !empty($filename))
		{
			$code = @implode('', @file($filename));
		}

		// Replace phpBB 2.2 <!-- (END)PHP --> tags
		$search = array('<!-- PHP -->', '<!-- ENDPHP -->');
		$replace = array('<'.'?php ', ' ?'.'>');
		$code = str_replace($search, $replace, $code);

		// Break it up into lines and put " -->" back.
		$code_lines = explode(' -->', $code);
		$count = count($code_lines);
		for ($i = 0; $i < ($count - 1); $i++)
		{
			$code_lines[$i] .= ' -->';
		}

		$block_nesting_level = 0;
		$block_names = array();
		$block_names[0] = ".";
		$block_items = array();
		$count_if = 0;

		// prepare array for compiled code
		$compiled = array();
		$count_bugs = count($this->bugs);

		// array of switches
		$sw = array();

		// replace all short php tags
		$new_code = array();
		$line_count = count($code_lines);
		for($i=0; $i<$line_count; $i++)
		{
			$line = $code_lines[$i];
			$pos = strpos($line, '<?');
			if($pos === false)
			{
				$new_code[] = $line;
				continue;
			}
			if(substr($line, $pos, 5) === '<?php')
			{
				// valid php tag. skip it
				$new_code[] = substr($line, 0, $pos + 5);
				$code_lines[$i] = substr($line, $pos + 5);
				$i --;
				continue;
			}
			// invalid php tag
			$new_code[] = substr($line, 0, $pos) . '<?php echo \'<?\'; ?>';
			$code_lines[$i] = substr($line, $pos + 2);
			$i --;
		}
		$code_lines = $new_code;

		// main loop
		$line_count = count($code_lines);
		for($i=0; $i<$line_count; $i++)
		{
			$line = $code_lines[$i];
			// reset keyword type
			$keyword_type = XS_TAG_NONE;
			// check if we have valid keyword in current line
			$pos1 = strpos($line, '<!-- ');
			if($pos1 === false)
			{
				// no keywords in this line
				$compiled[] = $this->_compile_text($line, $use_isset);
				continue;
			}
			// find end of html comment
			$pos2 = strpos($line, '-->', $pos1);
			if($pos2 !== false)
			{
				// find end of keyword in comment
				$pos3 = strpos($line, ' ', $pos1 + 5);
				if($pos3 !== false && $pos3 <= $pos2)
				{
					$keyword = substr($line, $pos1 + 5, $pos3 - $pos1 - 5);
					// check keyword against list of supported keywords. case-sensitive
					if($keyword === 'BEGIN')
					{
						$keyword_type = XS_TAG_BEGIN;
					}
					elseif($keyword === 'END')
					{
						$keyword_type = XS_TAG_END;
					}
					elseif($keyword === 'INCLUDE')
					{
						$keyword_type = XS_TAG_INCLUDE;
					}
					elseif($keyword === 'IF')
					{
						$keyword_type = XS_TAG_IF;
					}
					elseif($keyword === 'ELSE')
					{
						$keyword_type = XS_TAG_ELSE;
					}
					elseif($keyword === 'ELSEIF')
					{
						$keyword_type = XS_TAG_ELSEIF;
					}
					elseif($keyword === 'ENDIF')
					{
						$keyword_type = XS_TAG_ENDIF;
					}
					elseif($keyword === 'DEFINE')
					{
						$keyword_type = XS_TAG_DEFINE;
					}
					elseif($keyword === 'UNDEFINE')
					{
						$keyword_type = XS_TAG_UNDEFINE;
					}
					elseif($keyword === 'BEGINELSE')
					{
						$keyword_type = XS_TAG_BEGINELSE;
					}
				}
			}
			if(!$keyword_type)
			{
				// not valid keyword. process the rest of line
				$compiled[] = $this->_compile_text(substr($line, 0, $pos1 + 4), $use_isset);
				$code_lines[$i] = substr($line, $pos1 + 4);
				$i --;
				continue;
			}
			// remove code before keyword
			if($pos1 > 0)
			{
				$compiled[] = $this->_compile_text(substr($line, 0, $pos1), $use_isset);
			}
			// remove keyword
			$keyword_str = substr($line, $pos1, $pos2 - $pos1 + 4);
			$params_str = ($pos2 == $pos3) ? '' : trim(substr($line, $pos3 + 1, $pos2 - $pos3 - 1));
			$code_lines[$i] = substr($line, $pos2 + 4);
			$i--;
			// Check keywords

			/*
			* <!-- BEGIN -->
			*/
			if($keyword_type == XS_TAG_BEGIN)
			{
				$params = explode(' ', $params_str);
				$num_params = count($params);
				// get variable name
				if($num_params == 1)
				{
					$var = $params[0];
				}
				elseif($num_params == 2)
				{
					if($params[0] === '')
					{
						$var = $params[1];
					}
					elseif($params[1] === '')
					{
						$var = $params[0];
					}
					else
					{
						// invalid tag
						$compiled[] = $keyword_str;
						continue;
					}
				}
				else
				{
					// invalid tag
					$compiled[] = $keyword_str;
					continue;
				}
				// check variable for matching end
				if($this->xs_check_switches)
				{
					$found = 0;
					$str = '<!-- END ' . $var . ' -->';
					for ($j = $i+1; ($j < $line_count) && !$found; $j++)
					{
						$pos = strpos($code_lines[$j], $str);
						if($pos !== false)
						{
							$found = 1;
							$found_var = $var;
						}
					}
					if(!$found && ($this->xs_check_switches == 1))
					{
						// checking list of known buggy switches
						$item = -1;
						for($j=0; $j<$count_bugs; $j++)
						{
							if($this->bugs[$j][0] === $var)
							{
								$item = $j;
							}
						}
						if($item >= 0)
						{
							$str1 = '<!-- END ' . $this->bugs[$item][1] . ' -->';
							for ($j = $i+1; ($j < $line_count) && !$found; $j++)
							{
								$pos = strpos($code_lines[$j], $str1);
								if($pos !== false)
								{
									$found_var = $this->bugs[$item][1];
									$found = 1;
									$code_lines[$j] = str_replace($str, $str1, $code_lines[$j]);
								}
							}
						}
					}
					if(!$found)
					{
						$compiled[] = $keyword_str;
						continue;
					}
					// adding to list of switches
					if(isset($sw[$found_var]))
					{
						$sw[$found_var] ++;
					}
					else
					{
						$sw[$found_var] = 1;
					}
				}
				// adding code
				$block_nesting_level++;
				$block_names[$block_nesting_level] = $var;
				if(isset($block_items[$var]))
				{
					$block_items[$var] ++;
				}
				else
				{
					$block_items[$var] = 1;
				}
				if ($block_nesting_level < 2)
				{
					// Block is not nested.
					$line = '<'."?php\n\n";
					if($use_isset)
					{
						$line .= '$'. $var. '_count = ( isset($this->_tpldata[\''. $var. '.\']) ) ?  sizeof($this->_tpldata[\''. $var. '.\']) : 0;';
					}
					else
					{
						$line .= '$'. $var. '_count = sizeof($this->_tpldata[\''. $var. '.\']);';
					}
					$line .= "\n" . 'for ($'. $var. '_i = 0; $'. $var. '_i < $'. $var. '_count; $'. $var. '_i++)';
					$line .= "\n". '{'. "\n";
					$line .= ' $'. $var. '_item = &$this->_tpldata[\''. $var. '.\'][$'. $var. '_i];'."\n";
					$line .= " \${$var}_item['S_ROW_COUNT'] = \${$var}_i;\n";
					$line .= " \${$var}_item['S_NUM_ROWS'] = \${$var}_count;\n";
					$line .= "\n?".">";
				}
				else
				{
					// This block is nested.
					// Generate a namespace string for this block.
					$namespace = implode('.', $block_names);
					// strip leading period from root level..
					$namespace = substr($namespace, 2);
					// Get a reference to the data array for this block that depends on the
					// current indices of all parent blocks.
					$varref = $this->generate_block_data_ref($namespace, false);
					// Create the for loop code to iterate over this block.
					$line = '<'."?php\n\n";
					if($use_isset)
					{
						$line .= '$'. $var. '_count = ( isset('. $varref. ') ) ? sizeof('. $varref. ') : 0;';
					}
					else
					{
						$line .= '$'. $var. '_count = sizeof('. $varref. ');';
					}
					$line .= "\n". 'for ($'. $var. '_i = 0; $'. $var. '_i < $'. $var. '_count; $'. $var. '_i++)';
					$line .= "\n". '{'. "\n";
					$line .= ' $'. $var. '_item = &'. $varref. '[$'. $var. '_i];'."\n";
					$line .= " \${$var}_item['S_ROW_COUNT'] = \${$var}_i;\n";
					$line .= " \${$var}_item['S_NUM_ROWS'] = \${$var}_count;\n";
					$line .= "\n?".">";
				}
				$compiled[] = $line;
				continue;
			}
			/*
			* <!-- END -->
			*/
			if($keyword_type == XS_TAG_END)
			{
				$params = explode(' ', $params_str);
				$num_params = count($params);
				if($num_params == 1)
				{
					$var = $params[0];
				}
				elseif($num_params == 2 && $params[0] === '')
				{
					$var = $params[1];
				}
				elseif($num_params == 2 && $params[1] === '')
				{
					$var = $params[0];
				}
				else
				{
					$compiled[] = $keyword_str;
					continue;
				}
				if($this->xs_check_switches)
				{
					// checking if this switch was opened
					if(!isset($sw[$var]) || ($sw[$var] < 1))
					{
						// there is no opening switch
						$compiled[] = $keyword_str;
						continue;
					}
					$sw[$var] --;
				}
				// We have the end of a block.
				$line = '<'."?php\n\n";
				$line .= '} // END ' . $var . "\n\n";
				$line .= 'if(isset($' . $var . '_item)) { unset($' . $var . '_item); } ';
				$line .= "\n\n?".">";
				if(isset($block_items[$var]))
				{
					$block_items[$var] --;
				}
				else
				{
					$block_items[$var] = -1;
				}
				unset($block_names[$block_nesting_level]);
				$block_nesting_level--;
				$compiled[] = $line;
				continue;
			}
			/*
			* <!-- BEGINELSE -->
			*/
			if($keyword_type == XS_TAG_BEGINELSE)
			{
				if($block_nesting_level)
				{
					$var = $block_names[$block_nesting_level];
					$compiled[] = '<' . '?php } if(!$' . $var . '_count) { ?' . '>';
				}
				else
				{
					$compiled[] = $keyword_str;
					continue;
				}
			}
			/*
			* <!-- INCLUDE -->
			*/
			if($keyword_type == XS_TAG_INCLUDE)
			{
				$params = explode(' ', $params_str);
				$num_params = count($params);
				if($num_params != 1)
				{
					$compiled[] = $keyword_str;
					continue;
				}
				$line = '<'.'?php ';
				$filehash = md5($params_str . $this->include_count . time());
				$line .= ' $this->set_filename(\'xs_include_' . $filehash . '\', \'' . $params_str .'\', true); ';
				$line .= ' $this->pparse(\'xs_include_' . $filehash . '\'); ';
				$line .= ' ?'.'>';
				$this->include_count ++;
				$compiled[] = $line;
				continue;
			}
			/*
			* <!-- IF -->
			*/
			if($keyword_type == XS_TAG_IF || $keyword_type == XS_TAG_ELSEIF)
			{
				if(!$count_if)
				{
					$keyword_type = XS_TAG_IF;
				}
				$str = $this->compile_tag_if($params_str, $keyword_type == XS_TAG_IF ? false : true);
				if($str)
				{
					$compiled[] = '<?php ' . $str . ' ?>';
					if($keyword_type == XS_TAG_IF)
					{
						$count_if ++;
					}
				}
				else
				{
					$compiled[] = $keyword_str;
				}
				continue;
			}
			/*
			* <!-- ELSE -->
			*/
			if($keyword_type == XS_TAG_ELSE && $count_if > 0)
			{
				$compiled[] = '<?php } else { ?>';
				continue;
			}
			/*
			* <!-- ENDIF -->
			*/
			if($keyword_type == XS_TAG_ENDIF && $count_if > 0)
			{
				$compiled[] = '<?php } ?>';
				$count_if --;
				continue;
			}
			/*
			* <!-- DEFINE -->
			*/
			if($keyword_type == XS_TAG_DEFINE)
			{
				$str = $this->compile_tag_define($params_str);
				if($str)
				{
					$compiled[] = '<?php ' . $str . ' ?>';
				}
				else
				{
					$compiled[] = $keyword_str;
				}
			}
			/*
			* <!-- UNDEFINE -->
			*/
			if($keyword_type == XS_TAG_UNDEFINE)
			{
				$str = $this->compile_tag_undefine($params_str);
				if($str)
				{
					$compiled[] = '<?php ' . $str . ' ?>';
				}
				else
				{
					$compiled[] = $keyword_str;
				}
			}
		}

		// bring it back into a single string.
		$code_header = '';
		$code_footer = '';
		if(!$use_isset)
		{
			$code_header =	"<". "?php\n\$old_level = @error_reporting(E_ERROR | E_WARNING | E_PARSE); \n?".">";
			$code_footer = '<'."?php @error_reporting(\$old_level); ?".'>';
		}

		return $code_header . implode('', $compiled) . $code_footer;
	}	
	
	/**
	* Compile variables
	* @access private
	*/	
	function compile_code($filename, $code, $use_isset = false)
	{
		global $mx_user;
		//	$filename - file to load code from. used if $code is empty
		//	$code - tpl code
		//	$use_isset - if false then compiled code looks more beautiful and easier
		//      to understand and it adds error_reporting() to supress php warnings.
		//      if true then isset() is used to check variables instead of supressing
		//	    php warnings. note: for extreme styles mod 2.x it works only for
		//		block variables and for usual variables its always true.

		// load code from file
		if(!$code && !empty($filename))
		{
			$code = @implode('', @file($filename));
		}
		// Our phpBB tags
		// Commented out tokens are handled separately from the main replace
		$phpbb_tags = array(
			/*'BEGIN',
			'BEGINELSE',
			'END',
			'IF',
			'ELSE',
			'ELSEIF',
			'ENDIF',
			'DEFINE',
			'UNDEFINE',*/
			'ENDDEFINE',
			'INCLUDE',
			'INCLUDEPHP',
			'INCLUDEJS',
			'INCLUDECSS',
			'PHP',
			'ENDPHP',
			'EVENT',
		);

		// Twig tag masks
		$twig_tags = array(
			'autoescape',
			'endautoescape',
			'if',
			'elseif',
			'else',
			'endif',
			'block',
			'endblock',
			'use',
			'extends',
			'embed',
			'filter',
			'endfilter',
			'flush',
			'for',
			'endfor',
			'macro',
			'endmacro',
			'import',
			'from',
			'sandbox',
			'endsandbox',
			'set',
			'endset',
			//'spaceless',
			//'endspaceless',
			'verbatim',
			'endverbatim',
		);
		
		/** Remove any "loose" php ... we want to give admins the ability
		/** to switch on/off PHP for a given template. Allowing unchecked
		/** php is a no-no. There is a potential issue here in that non-php
		/** content may be removed ... however designers should use entities
		/** if they wish to display < and > ** /
		$this->remove_php_tags($code);
		
		/** Replace some unitialised  page_header() tags **/
		$code = str_replace('{TEMPLATE_ROOT_PATH}', TEMPLATE_ROOT_PATH, $code);			
		$code = str_replace('{U_PORTAL_ROOT_PATH}', PORTAL_URL, $code);		
		$code = str_replace('{U_PHPBB_ROOT_PATH}', PHPBB_URL, $code);
		$code = str_replace('{T_MXBB_STYLESHEET}', $mx_user->theme['head_stylesheet'], $code);	
		
		/** Replace phpBB 2.2 <!-- (END)PHP --> tags **/
		preg_match_all('#<!-- PHP -->(.*?)<!-- ENDPHP -->#s', $code, $matches);
		$php_blocks = $matches[1];
		$code = preg_replace('#<!-- PHP -->.*?<!-- ENDPHP -->#s', '<!-- PHP -->', $code);
		$code = str_replace('$HAS_SUB', 'S_HAS_SUBFORUM', $code);
		$code = str_replace('.topicrow', 'S_HAS_SUBFORUM', $code);		
		$code = str_replace('not .notifications', 'not NOTIFICATIONS_COUNT', $code);		
		$code = str_replace('.birthdays', 'S_DISPLAY_BIRTHDAY_LIST', $code);		
		
		$code = str_replace('.postrow.contact', '$postrow_item[\'contact.\']', $code);
		$code = str_replace('.pagination or', 'PAGINATION or', $code); 	
		$code = str_replace('.pagination', 'PAGINATION', $code);
		$code = str_replace('.quickmod', 'QUICKMOD', $code);		
		
		/** Pull out all block/statement level elements and separate plain text **/
		preg_match_all('#<!-- INCLUDE (\{\$?[A-Z0-9\-_]+\}|[a-zA-Z0-9\_\-\+\./]+) -->#', $code, $matches);
		$include_blocks = $matches[1];
		
		//$code = preg_replace('#<!-- INCLUDE (?:\{\$?[A-Z0-9\-_]+\}|[a-zA-Z0-9\_\-\+\./]+) -->#', '<!-- INCLUDEX -->', $code);
		
		/** Remove overall_header and overall_footer included in MX-PORTAL and phpBB2 and mx_phpbb3 Forum Integration 
		via page_header.php and page_tail.php **/
		$code = str_replace('<!-- INCLUDE overall', '<!-- INCLUDEX overall', $code);
				
		
		
		/** Pull out all block/statement level elements and separate plain text **/
		preg_match_all('#<!-- INCLUDEPHP ([a-zA-Z0-9\_\-\+\./]+) -->#', $code, $matches);
		$includephp_blocks = $matches[1];
		$code = preg_replace('#<!-- INCLUDEPHP [a-zA-Z0-9\_\-\+\./]+ -->#', '<!-- INCLUDEPHP -->', $code);		
		
		/** Pull out all block/statement level elements and separate plain text ** /		
		preg_match_all('#<!-- ([^<].*?) (.*?)? ?-->#', $code, $blocks, PREG_SET_ORDER);
		
		/** Pull out all block/statement level elements and separate plain text ** /
		$text_blocks = preg_split('#<!-- [^<].*? (?:.*?)? ?-->#', $code);		

		
		/** Fix tokens that may have inline variables (e.g. <!-- DEFINE $TEST = '{FOO}')   ** /
		$code = $this->strip_surrounding_quotes(array(
			'INCLUDE',
			'INCLUDEPHP',
			'INCLUDEJS',
			'INCLUDECSS',
		), $code);
		/** Fix tokens   ** /
		$code = $this->fix_inline_variable_tokens(array(
			'DEFINE \$[a-zA-Z0-9_]+ =',
			'INCLUDE',
			'INCLUDEPHP',
			'INCLUDEJS',
			'INCLUDECSS',
		), $code);
		/** Fix tokens   ** /
		$code = $this->add_surrounding_quotes(array(
			'INCLUDE',
			'INCLUDEPHP',
			'INCLUDEJS',
			'INCLUDECSS',
		), $code);

		/** Fix our BEGIN statements **/
		//$code = $this->fix_begin_tokens($code);
		//$code = $this->fix_tokens_begin($code);
		/** Fix our BEGIN statements step2 **/
		$code = str_replace('{% else %}', '<!-- BEGINELSE -->', $code);
		
		$code = str_replace('{% set', '<!-- SET', $code);		
		$code = str_replace('%}', '-->', $code);
		
		/** Fix our BEGIN statements step3 this will break mx_main_layout.html and mx_menu_classic_ver.html. ** /
		$code = str_replace('%', '--', $code);		
		
		/**Fix our IF tokens **/
		// $code = $this->fix_if_tokens($code);
		
		// Replace ELSE IF with ELSEIF
		$code = preg_replace('#<!-- ELSE IF (.+?) -->#', '<!-- ELSEIF $1 -->', $code);
		
		/** Fix our DEFINE tokens **/
		// $code = $this->fix_define_tokens($code);
		$code = $this->fix_tokens_define($code);
		
		/** Replace all of our starting tokens, <!-- TOKEN --> with Twig style, {% TOKEN %}
		// This also strips outer parenthesis, <!-- IF (blah) --> becomes <!-- IF blah -->  ** /
		$code = preg_replace('#<!-- (' . implode('|', $phpbb_tags) . ')(?: (.*?) ?)?-->#', '{% $1 $2 %}', $code);

		/**Replace all of our twig masks with Twig code (e.g. <!-- BLOCK .+ --> with {% block $1 %})  ** /
		$code = $this->replace_tag_twig_masks($code, $twig_tags);
		//$code = $this->replace_twig_tag_masks($code, $twig_tags);
		
		/** Replace all of our language variables, {L_VARNAME}, with Twig style, {{ lang('NAME') }}
		// Appends any filters after lang() ** /
		$code = preg_replace('#{L_([a-zA-Z0-9_\.]+)(\|[^}]+?)?}#', '{{ lang(\'$1\')$2 }}', $code);

		/** Replace all of our escaped language variables, {LA_VARNAME}, with Twig style, {{ lang('NAME')|escape('js') }}
		// Appends any filters after lang(), but before escape('js')  ** /
		$code = preg_replace('#{LA_([a-zA-Z0-9_\.]+)(\|[^}]+?)?}#', '{{ lang(\'$1\')$2|escape(\'js\') }}', $code);

		/** Replace all of our variables, {VARNAME}, with Twig style, {{ VARNAME }}  ** /
		$code = preg_replace('#{([a-zA-Z0-9_\.]+)(\|[^}]+?)?}#', '{{ $1$2 }}', $code);
		/**Appends any filters  **/
		
		/** Replace .foo with $foo  **/
		$code = preg_replace('#(\s\(*!?)\.([a-zA-Z_0-9]+)([^a-zA-Z_0-9\.])#', '$1\$$2 ', $code);
		$code = preg_replace('#(\s\(*!?)\.([a-zA-Z_0-9]+)([^a-zA-Z_0-9\.])#', '$1\$$2 ', $code);

		/**Replace .foo.bar with foo.bar|length **/
		$code = preg_replace('#(\s\(*!?)\.([a-zA-Z_0-9\.]+)([^a-zA-Z_0-9\.])#', '$1$2|length$3', $code);		
		
		/** Break it up into lines and put " -->" back. **/
	
		$code_lines = explode(' -->', $code);
		$count = count($code_lines);
		for ($i = 0; $i < ($count - 1); $i++)
		{
			$code_lines[$i] .= ' -->';
		}

		$block_nesting_level = 0;
		$block_names = array();
		$block_names[0] = ".";
		$block_items = array();
		$count_if = 0;

		// prepare array for compiled code
		$compiled = array();
		$count_bugs = count($this->bugs);

		// array of switches
		$sw = array();

		// replace all short php tags
		$new_code = array();
		$line_count = count($code_lines);
		for($i = 0; $i < $line_count; $i++)
		{
			$line = $code_lines[$i];
			$pos = strpos($line, '<?');
			if($pos === false)
			{
				$new_code[] = $line;
				continue;
			}
			if(substr($line, $pos, 5) === '<?php')
			{
				// valid php tag. skip it
				$new_code[] = substr($line, 0, $pos + 5);
				$code_lines[$i] = substr($line, $pos + 5);
				$i --;
				continue;
			}
			// invalid php tag
			$new_code[] = substr($line, 0, $pos) . '<?php echo \'<?\'; ?>';
			$code_lines[$i] = substr($line, $pos + 2);
			$i --;
		}
		$code_lines = $new_code;

		// main loop
		$line_count = count($code_lines);
		for($i = 0; $i < $line_count; $i++)
		{
			$line = $code_lines[$i];
			// reset keyword type
			$keyword_type = XS_TAG_NONE;
			// check if we have valid keyword in current line
			$pos1 = strpos($line, '<!-- ');
			if($pos1 === false)
			{
				// no keywords in this line
				$compiled[] = $this->_compile_text($line, $use_isset);
				continue;
			}
			// find end of html comment
			$pos2 = strpos($line, ' -->', $pos1);
			if($pos2 !== false)
			{
				// find end of keyword in comment
				$pos3 = strpos($line, ' ', $pos1 + 5);
				if($pos3 !== false && $pos3 <= $pos2)
				{
					$keyword = substr($line, $pos1 + 5, $pos3 - $pos1 - 5);
					// check keyword against list of supported keywords. case-sensitive
					if($keyword === 'BEGIN')
					{
						$keyword_type = XS_TAG_BEGIN;
					}
					elseif($keyword === 'END')
					{
						$keyword_type = XS_TAG_END;
					}
					elseif($keyword === 'INCLUDE')
					{
						$keyword_type = XS_TAG_INCLUDE;
					}
					elseif($keyword === 'IF')
					{
						$keyword_type = XS_TAG_IF;
					}
					elseif($keyword === 'ELSE')
					{
						$keyword_type = XS_TAG_ELSE;
					}
					elseif($keyword === 'ELSEIF')
					{
						$keyword_type = XS_TAG_ELSEIF;
					}
					elseif($keyword === 'ENDIF')
					{
						$keyword_type = XS_TAG_ENDIF;
					}
					elseif($keyword === 'DEFINE')
					{
						$keyword_type = XS_TAG_DEFINE;
					}
					elseif($keyword === 'UNDEFINE')
					{
						$keyword_type = XS_TAG_UNDEFINE;
					}
					elseif($keyword === 'BEGINELSE')
					{
						$keyword_type = XS_TAG_BEGINELSE;
					}
				}
			}
			if(!$keyword_type)
			{
				// not valid keyword. process the rest of line
				$compiled[] = $this->_compile_text(substr($line, 0, $pos1 + 4), $use_isset);
				$code_lines[$i] = substr($line, $pos1 + 4);
				$i --;
				continue;
			}
			// remove code before keyword
			if($pos1 > 0)
			{
				$compiled[] = $this->_compile_text(substr($line, 0, $pos1), $use_isset);
			}
			// remove keyword
			$keyword_str = substr($line, $pos1, $pos2 - $pos1 + 4);
			$params_str = $pos2 == $pos3 ? '' : substr($line, $pos3 + 1, $pos2 - $pos3 - 1);
			$code_lines[$i] = substr($line, $pos2 + 4);
			$i--;
			// Check keywords

			/*
			* <!-- BEGIN -->
			*/
			if($keyword_type == XS_TAG_BEGIN)
			{
				$params = explode(' ', $params_str);
				$num_params = count($params);
				// get variable name
				if($num_params == 1)
				{
					$var = $params[0];
				}
				elseif($num_params == 2)
				{
					if($params[0] === '')
					{
						$var = $params[1];
					}
					elseif($params[1] === '')
					{
						$var = $params[0];
					}
					else
					{
						// invalid tag
						$compiled[] = $keyword_str;
						continue;
					}
				}
				else
				{
					// invalid tag
					$compiled[] = $keyword_str;
					continue;
				}
				// check variable for matching end
				if($this->xs_check_switches)
				{
					$found = 0;
					$str = '<!-- END ' . $var . ' -->';
					for ($j = $i+1; ($j < $line_count) && !$found; $j++)
					{
						$pos = strpos($code_lines[$j], $str);
						if($pos !== false)
						{
							$found = 1;
							$found_var = $var;
						}
					}
					if(!$found && ($this->xs_check_switches == 1))
					{
						// checking list of known buggy switches
						$item = -1;
						for($j=0; $j<$count_bugs; $j++)
						{
							if($this->bugs[$j][0] === $var)
							{
								$item = $j;
							}
						}
						if($item >= 0)
						{
							$str1 = '<!-- END ' . $this->bugs[$item][1] . ' -->';
							for ($j = $i+1; ($j < $line_count) && !$found; $j++)
							{
								$pos = strpos($code_lines[$j], $str1);
								if($pos !== false)
								{
									$found_var = $this->bugs[$item][1];
									$found = 1;
									$code_lines[$j] = str_replace($str, $str1, $code_lines[$j]);
								}
							}
						}
					}
					if(!$found)
					{
						$compiled[] = $keyword_str;
						continue;
					}
					// adding to list of switches
					if(isset($sw[$found_var]))
					{
						$sw[$found_var] ++;
					}
					else
					{
						$sw[$found_var] = 1;
					}
				}
				// adding code
				$block_nesting_level++;
				$block_names[$block_nesting_level] = $var;
				if(isset($block_items[$var]))
				{
					$block_items[$var] ++;
				}
				else
				{
					$block_items[$var] = 1;
				}
				if ($block_nesting_level < 2)
				{
					// Block is not nested.
					$line = '<'."?php\n\n";
					if($use_isset)
					{
						$line .= '$'. $var. '_count = ( isset($this->_tpldata[\''. $var. '.\']) ) ?  sizeof($this->_tpldata[\''. $var. '.\']) : 0;';
					}
					else
					{
						$line .= '$'. $var. '_count = sizeof($this->_tpldata[\''. $var. '.\']);';
					}
					$line .= "\n" . 'for ($'. $var. '_i = 0; $'. $var. '_i < $'. $var. '_count; $'. $var. '_i++)';
					$line .= "\n". '{'. "\n";
					$line .= ' $'. $var. '_item = &$this->_tpldata[\''. $var. '.\'][$'. $var. '_i];'."\n";
					$line .= " \${$var}_item['S_ROW_COUNT'] = \${$var}_i;\n";
					$line .= " \${$var}_item['S_NUM_ROWS'] = \${$var}_count;\n";
					$line .= "\n?".">";
				}
				else
				{
					// This block is nested.
					// Generate a namespace string for this block.
					$namespace = implode('.', $block_names);
					// strip leading period from root level..
					$namespace = substr($namespace, 2);
					// Get a reference to the data array for this block that depends on the
					// current indices of all parent blocks.
					$varref = $this->generate_block_data_ref($namespace, false);
					// Create the for loop code to iterate over this block.
					$line = '<'."?php\n\n";
					if($use_isset)
					{
						$line .= '$'. $var . '_count = ( isset('. $varref . ') ) ? sizeof('. $varref . ') : 0;';
					}
					else
					{
						$line .= '$'. $var . '_count = sizeof('. $varref . ');';
					}
					$line .= "\n". 'for ($'. $var . '_i = 0; $'. $var . '_i < $'. $var . '_count; $'. $var . '_i++)';
					$line .= "\n". '{'. "\n";
					$line .= ' $'. $var . '_item = &'. $varref . '[$'. $var . '_i];'."\n";
					$line .= " \${$var}_item['S_ROW_COUNT'] = \${$var}_i;\n";
					$line .= " \${$var}_item['S_NUM_ROWS'] = \${$var}_count;\n";
					$line .= "\n?".">";
				}
				$compiled[] = $line;
				continue;
			}
			/*
			* <!-- END -->
			*/
			if($keyword_type == XS_TAG_END)
			{
				$params = explode(' ', $params_str);
				$num_params = count($params);
				if($num_params == 1)
				{
					$var = $params[0];
				}
				elseif($num_params == 2 && $params[0] === '')
				{
					$var = $params[1];
				}
				elseif($num_params == 2 && $params[1] === '')
				{
					$var = $params[0];
				}
				else
				{
					$compiled[] = $keyword_str;
					continue;
				}
				if($this->xs_check_switches)
				{
					// checking if this switch was opened
					if(!isset($sw[$var]) || ($sw[$var] < 1))
					{
						// there is no opening switch
						$compiled[] = $keyword_str;
						continue;
					}
					$sw[$var] --;
				}
				// We have the end of a block.
				$line = '<'."?php\n\n";
				$line .= '} // END ' . $var . "\n\n";
				$line .= 'if(isset($' . $var . '_item)) { unset($' . $var . '_item); } ';
				$line .= "\n\n?".">";
				if(isset($block_items[$var]))
				{
					$block_items[$var] --;
				}
				else
				{
					$block_items[$var] = -1;
				}
				unset($block_names[$block_nesting_level]);
				$block_nesting_level--;
				$compiled[] = $line;
				continue;
			}
			/*
			* <!-- BEGINELSE -->
			*/
			if($keyword_type == XS_TAG_BEGINELSE)
			{
				if($block_nesting_level)
				{
					$var = $block_names[$block_nesting_level];
					$compiled[] = '<' . '?php } if(!$' . $var . '_count) { ?' . '>';
				}
				else
				{
					$compiled[] = $keyword_str;
					continue;
				}
			}
			/*
			* <!-- INCLUDE -->
			*/
			if($keyword_type == XS_TAG_INCLUDE)
			{
				$params = explode(' ', $params_str);
				$num_params = count($params);
				if($num_params != 1)
				{
					$compiled[] = $keyword_str;
					continue;
				}
				$line = '<'.'?php ';
				$filehash = md5($params_str . $this->include_count . time());
				$line .= ' $this->set_filename(\'xs_include_' . $filehash . '\', \'' . $params_str .'\', true); ';
				$line .= ' $this->pparse(\'xs_include_' . $filehash . '\'); ';
				$line .= ' ?'.'>';
				$this->include_count ++;
				$compiled[] = $line;
				continue;
			}
			/*
			* <!-- IF -->
			*/
			if($keyword_type == XS_TAG_IF || $keyword_type == XS_TAG_ELSEIF)
			{
				if(!$count_if)
				{
					$keyword_type = XS_TAG_IF;
				}
				$str = $this->compile_tag_if($params_str, $keyword_type == XS_TAG_IF ? false : true);
				if($str)
				{
					$compiled[] = '<?php ' . $str . ' ?>';
					if($keyword_type == XS_TAG_IF)
					{
						$count_if ++;
					}
				}
				else
				{
					$compiled[] = $keyword_str;
				}
				continue;
			}
			/*
			* <!-- ELSE -->
			*/
			if($keyword_type == XS_TAG_ELSE && $count_if > 0)
			{
				$compiled[] = '<?php } else { ?>';
				continue;
			}
			/*
			* <!-- ENDIF -->
			*/
			if($keyword_type == XS_TAG_ENDIF && $count_if > 0)
			{
				$compiled[] = '<?php } ?>';
				$count_if --;
				continue;
			}
			/*
			* <!-- DEFINE -->
			*/
			if($keyword_type == XS_TAG_DEFINE)
			{
				$str = $this->compile_tag_define($params_str);
				if($str)
				{
					$compiled[] = '<?php ' . $str . ' ?>';
				}
				else
				{
					$compiled[] = $keyword_str;
				}
			}
			/*
			* <!-- UNDEFINE -->
			*/
			if($keyword_type == XS_TAG_UNDEFINE)
			{
				$str = $this->compile_tag_undefine($params_str);
				if($str)
				{
					$compiled[] = '<?php ' . $str . ' ?>';
				}
				else
				{
					$compiled[] = $keyword_str;
				}
			}
		}

		// bring it back into a single string.
		$code_header = '';
		$code_footer = '';
		if(!$use_isset)
		{
			$code_header =	"<". "?php\n\$old_level = @error_reporting(E_ERROR | E_WARNING | E_PARSE); \n?".">";
			$code_footer = '<'."?php @error_reporting(\$old_level); ?".'>';
		}

		return $code_header . implode('', $compiled) . $code_footer;
	}
	
	/**
	* Get template vars in a format Twig will use (from the context)
	*
	* @return array
	*/
	function get_template_vars()
	{
		$context_vars = $this->get_data_ref();

		$vars = array_merge(
			$context_vars, // To get normal vars
			array(
				'definition'	=> new definition(),
				'user'			=> $this->user,
				'loops'			=> $context_vars, // To get loops
			)
		);

		// cleanup
		unset($vars['loops']['.']);

		return $vars;
	}	
	
	/**
	* Compile variables
	* @access private
	*/
	function compile_var_tags(&$text_blocks)
	{
		// change template varrefs into PHP varrefs
		$varrefs = array();

		// This one will handle varrefs WITH namespaces
		preg_match_all('#\{((?:[a-z0-9\-_]+\.)+)(\$)?([A-Z0-9\-_]+)\}#', $text_blocks, $varrefs, PREG_SET_ORDER);

		foreach ($varrefs as $var_val)
		{
			$namespace = $var_val[1];
			$varname = $var_val[3];
			$new = $this->generate_block_varref($namespace, $varname, true, $var_val[2]);

			$text_blocks = str_replace($var_val[0], $new, $text_blocks);
		}

		// This will handle the remaining root-level varrefs
		// transform vars prefixed by L_ into their language variable pendant if nothing is set within the tpldata array
		if (strpos($text_blocks, '{L_') !== false)
		{
			$text_blocks = preg_replace('#\{L_([A-Z0-9\-_]+)\}#', "<?php echo ((isset(\$this->_rootref['L_\\1'])) ? \$this->_rootref['L_\\1'] : ((isset(\$mx_user->lang['\\1'])) ? \$mx_user->lang['\\1'] : '{ \\1 }')); ?>", $text_blocks);
		}

		// Handle addslashed language variables prefixed with LA_
		// If a template variable already exist, it will be used in favor of it...
		if (strpos($text_blocks, '{LA_') !== false)
		{
			$text_blocks = preg_replace('#\{LA_([A-Z0-9\-_]+)\}#', "<?php echo ((isset(\$this->_rootref['LA_\\1'])) ? \$this->_rootref['LA_\\1'] : ((isset(\$this->_rootref['L_\\1'])) ? addslashes(\$this->_rootref['L_\\1']) : ((isset(\$mx_user->lang['\\1'])) ? addslashes(\$mx_user->lang['\\1']) : '{ \\1 }'))); ?>", $text_blocks);
		}

		// Handle remaining varrefs
		$text_blocks = preg_replace('#\{([A-Z0-9\-_]+)\}#', "<?php echo (isset(\$this->_rootref['\\1'])) ? \$this->_rootref['\\1'] : ''; ?>", $text_blocks);
		$text_blocks = preg_replace('#\{\$([A-Z0-9\-_]+)\}#', "<?php echo (isset(\$this->_tpldata['DEFINE']['.']['\\1'])) ? \$this->_tpldata['DEFINE']['.']['\\1'] : ''; ?>", $text_blocks);

		return;
	}
	
	/*
	* Compile code between tags
	*/
	function _compile_text($code, $use_isset)
	{
		if(strlen($code) < 3)
		{
			return $code;
		}
		// change template varrefs into PHP varrefs
		// This one will handle varrefs WITH namespaces
		$varrefs = array();
		preg_match_all('#\{(([a-z0-9\-_]+?\.)+?)([a-z0-9\-_]+?)\}#is', $code, $varrefs);
		$varcount = sizeof($varrefs[1]);
		$search = array();
		$replace = array();
		for ($i = 0; $i < $varcount; $i++)
		{
			$namespace = $varrefs[1][$i];
			$varname = $varrefs[3][$i];
			$new = $this->generate_block_varref($namespace, $varname, $use_isset);
			$search[] = $varrefs[0][$i];
			$replace[] = $new;
		}
		if(count($search) > 0)
		{
			$code = str_replace($search, $replace, $code);
		}
		// This will handle the remaining root-level varrefs
		$code = preg_replace('#\{([a-z0-9\-_]*?)\}#is', '<'.'?php echo isset($this->vars[\'\1\']) ? $this->vars[\'\1\'] : $this->lang(\'\1\'); ?'.'>', $code);
		$code = preg_replace('#\{\$([a-z0-9\-_]*?)\}#is', '<'.'?php echo isset($this->_tpldata[\'DEFINE\'][\'.\'][\'\\1\']) ? $this->_tpldata[\'DEFINE\'][\'.\'][\'\\1\'] : \'\'; ?'.'>', $code);
		return $code;
	}

	//
	// Compile IF tags - much of this is from Smarty with
	// some adaptions for our block level methods
	//
	function compile_tag_if($tag_args, $elseif)
	{
        /* Tokenize args for 'if' tag. */
        preg_match_all('/(?:
                         "[^"\\\\]*(?:\\\\.[^"\\\\]*)*"         |
                         \'[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*\'     |
                         [(),]                                  |
                         [^\s(),]+)/x', $tag_args, $match);

        $tokens = $match[0];
        $is_arg_stack = array();

        for ($i = 0; $i < count($tokens); $i++)
		{
			$token = &$tokens[$i];

			switch ($token)
			{
                case '!':
                case '%':
                case '!==':
                case '==':
                case '===':
                case '>':
                case '<':
                case '!=':
                case '<>':
                case '<<':
                case '>>':
                case '<=':
                case '>=':
                case '&&':
                case '||':
				case '|':
				case '^':
				case '&':
				case '~':
				case ')':
				case ',':
				case '+':
				case '-':
				case '*':
				case '/':
				case '@':
					break;

				case 'eq':
					$token = '==';
					break;

				case 'ne':
				case 'neq':
					$token = '!=';
					break;

				case 'lt':
					$token = '<';
					break;

				case 'le':
				case 'lte':
					$token = '<=';
					break;

				case 'gt':
					$token = '>';
					break;

				case 'ge':
				case 'gte':
					$token = '>=';
					break;

				case 'and':
					$token = '&&';
					break;

				case 'or':
					$token = '||';
					break;

				case 'not':
					$token = '!';
					break;

				case 'mod':
					$token = '%';
					break;

				case '(':
					array_push($is_arg_stack, $i);
					break;

				case 'is':
					$is_arg_start = ($tokens[$i-1] == ')') ? array_pop($is_arg_stack) : $i-1;
					$is_arg	= implode('	', array_slice($tokens,	$is_arg_start, $i -	$is_arg_start));

					$new_tokens	= $this->_parse_is_expr($is_arg, array_slice($tokens, $i+1));

					array_splice($tokens, $is_arg_start, count($tokens), $new_tokens);

					$i = $is_arg_start;

				default:
					if (preg_match('#^(([a-z0-9\-_]+?\.)+?)?(\$)?([A-Z]+[A-Z0-9\-_]+)$#s', $token, $varrefs))
					{
						$token = (!empty($varrefs[1])) ? $this->generate_block_data_ref(substr($varrefs[1], 0, -1), true, $varrefs[3]) . '[\'' . $varrefs[4] . '\']' : (($varrefs[3]) ? '$this->_tpldata[\'DEFINE\'][\'.\'][\'' . $varrefs[4] . '\']' : '$this->vars[\'' . $varrefs[4] . '\']');
					}
					else if ( $token[0] == '.' )
					{
						$token = 'sizeOf( $this->_tpldata[\'' . substr( $token, 1) . '.\'])';
					}
					break;
            }
        }

		$code = (($elseif) ? '} elseif (' : 'if (') . (implode(' ', $tokens) . ') { ');

		return $code;
	}

	// This is from Smarty
	function _parse_is_expr($is_arg, $tokens)
	{
		$expr_end =	0;
		$negate_expr = false;

		if (($first_token = array_shift($tokens)) == 'not')
		{
			$negate_expr = true;
			$expr_type = array_shift($tokens);
		}
		else
		{
			$expr_type = $first_token;
		}

		switch ($expr_type)
		{
			case 'even':
				if (@$tokens[$expr_end] == 'by')
				{
					$expr_end++;
					$expr_arg =	$tokens[$expr_end++];
					$expr =	"!(($is_arg	/ $expr_arg) % $expr_arg)";
				}
				else
				{
					$expr =	"!($is_arg % 2)";
				}
			break;

			case 'odd':
				if (@$tokens[$expr_end] == 'by')
				{
					$expr_end++;
					$expr_arg =	$tokens[$expr_end++];
					$expr =	"(($is_arg / $expr_arg)	% $expr_arg)";
				}
				else
				{
					$expr =	"($is_arg %	2)";
				}
			break;

			case 'div':
				if (@$tokens[$expr_end] == 'by')
				{
					$expr_end++;
					$expr_arg =	$tokens[$expr_end++];
					$expr =	"!($is_arg % $expr_arg)";
				}
			break;

			default:
				break;
		}

		if ($negate_expr)
		{
			$expr =	"!($expr)";
		}

		array_splice($tokens, 0, $expr_end,	$expr);

		return $tokens;
	}


	function compile_tag_define($tag_args)
	{
		preg_match('#^(([a-z0-9\-_]+?\.)+?)?\$([A-Z][A-Z0-9_\-]*?) = (\'?)(.*?)(\'?)$#', $tag_args, $match);

		if (empty($match[3]) || empty($match[5]))
		{
			return '';
		}

		// Are we a string?
		if ($match[4] && $match[6])
		{
			$match[5] = "'" . addslashes(str_replace(array('\\\'', '\\\\'), array('\'', '\\'), $match[5])) . "'";
		}
		else
		{
			preg_match('#(true|false|\.)#i', $match[5], $type);
			// Aprint_r($type[1]);
			switch (@strtolower($type[1]))
			{
				case 'true':
				case 'false':
					$match[5] = strtoupper($match[5]);
				break;
				case '.';
					$match[5] = doubleval($match[5]);
				break;
				default:
					$match[5] = intval($match[5]);
				break;
			}
		}
		
		$tag_return = (($match[1]) ? $this->generate_block_data_ref(substr($match[1], 0, -1), true, true) . '[\'' . $match[3] . '\']' : '$this->_tpldata[\'DEFINE\'][\'.\'][\'' . $match[3] . '\']') . ' = ' . $match[5] . ';';
		
		return $tag_return;	
	}

	function compile_tag_undefine($tag_args)
	{
		preg_match('#^(([a-z0-9\-_]+?\.)+?)?\$([A-Z][A-Z0-9_\-]*?)$#', $tag_args, $match);
		if (empty($match[3]))
		{
			return '';
		}
		return 'unset(' . (($match[1]) ? $this->generate_block_data_ref(substr($match[1], 0, -1), true, true) . '[\'' . $match[3] . '\']' : '$this->_tpldata[\'DEFINE\'][\'.\'][\'' . $match[3] . '\']') . ');';
	}

	/**
	 * Compiles code and writes to cache if needed
	 */
	function compile2($code, $handle, $cache_file)
	{
		$code = $this->compile_code('', $code, XS_USE_ISSET);
		if($cache_file && !empty($this->use_cache) && !empty($this->auto_compile))
		{
			$res = $this->write_cache($cache_file, $code);
			if($handle && $res)
			{
				$this->files_cache[$handle] = $cache_file;
			}
		}
		$code = '?'.'>'.$code.'<'."?php\n";
		return $code;
	}

	/**
	 * Compiles the given string of code, and returns
	 * the result in a string.
	 * If "do_not_echo" is true, the returned code will not be directly
	 * executable, but can be used as part of a variable assignment
	 * for use in assign_code_from_handle().
	 * This function isn't used and kept only for compatibility with original template.php
	 */
	function compile($code, $do_not_echo = false, $retvar = '')
	{
		$code = ' ?'.'>' . $this->compile_code('', $code, true) . '<'."?php \n";
		if($do_not_echo)
		{
			$code = "ob_start();\n". $code. "\n\${$retvar} = ob_get_contents();\nob_end_clean();\n";
		}
		return $code;
	}

	/**
	 * Write cache to disk
	 */
	function write_cache($filename, $code)
	{
		// check if cache is writable
		if(!$this->cache_writable)
		{
			return false;
		}
		// check if filename is valid
		if(substr($filename, 0, strlen($this->cachedir)) !== $this->cachedir)
		{
			return false;
		}
		// try to open file
		$file = @fopen($filename, 'w');
		if(!$file)
		{
			// try to create directories
			$dir = substr($filename, strlen($this->cachedir), strlen($filename));
			$dirs = explode('/', $dir);
			$path = $this->cachedir;
			@umask(0);
			if(!@is_dir($path))
			{
				if(!@mkdir($path))
				{
					$this->cache_writable = 0;
					return false;
				}
				else
				{
					@chmod($path, 0777);
				}
			}
			$count = count($dirs);
			if($count > 0)
			for($i=0; $i<$count-1; $i++)
			{
				if($i>0)
				{
					$path .= '/';
				}
				$path .= $dirs[$i];
				if(!@is_dir($path))
				{
					if(!@mkdir($path))
					{
						$this->cache_writable = 0;
						return false;
					}
					else
					{
						@chmod($path, 0777);
					}
				}
			}
			// try to open file again after directories were created
			$file = @fopen($filename, 'w');
		}
		if(!$file)
		{
			$this->cache_writable = 0;
			return false;
		}
		fputs($file, "<?php\n\n// eXtreme Styles mod cache. Generated on " . date('r') . " (time=" . time() . ")\n\n?>");
		fputs($file, $code);
		fclose($file);
		@chmod($filename, 0777);
		return true;
	}

	function xs_startup()
	{
		global $phpEx, $board_config, $phpbb_root_path, $mx_root_path;
		if(empty($this->xs_started))
		{	// adding predefined variables
			$this->xs_started = 1;
			// file extension with session ID (eg: "php?sid=123&" or "php?")
			// can be used to make custom URLs without modding phpbb
			// contains "&" or "?" at the end so you can easily append paramenters
			$php = mx_append_sid($phpEx);
			if(strpos($php, '?'))
			{
				$php .= '&';
			}
			else
			{
				$php .= '?';
			}
			$this->vars['PHP'] = isset($this->vars['PHP']) ? $this->vars['PHP'] : $php;
			// adding language variable (eg: "english" or "german")
			// can be used to make truly multi-lingual templates
			$this->vars['LANG'] = isset($this->vars['LANG']) ? $this->vars['LANG'] : $board_config['default_lang'];
			// adding current template
			$tpl = $this->root . '/'; // $mx_root_path . 'templates/' . $this->tpl . '/';
			if(substr($tpl, 0, 2) === './')
			{
				$tpl = substr($tpl, 2, strlen($tpl));
			}
			$this->vars['TEMPLATE'] = isset($this->vars['TEMPLATE']) ? $this->vars['TEMPLATE'] : $tpl;
			$this->vars['TEMPLATE_NAME'] = isset($this->vars['TEMPLATE_NAME']) ? $this->vars['TEMPLATE_NAME'] : $this->tpl;
			$this->_tpldata['switch_xs_enabled.'] = array(array('version' => $this->xs_versiontxt));
		}
	}

	/**
	 * Checks for empty variable and shows language variable if possible.
	 */
	function lang($var)
	{
		global $lang;
		if(substr($var, 0, 2) === 'L_')
		{
			$var = substr($var, 2);
			// check variable as it is
			if(isset($lang[$var]))
			{
				return $lang[$var];
			}
			// check variable in lower case
			if(isset($lang[strtolower($var)]))
			{
				return $lang[strtolower($var)];
			}
			// check variable with first letter in upper case
			$str = ucfirst(strtolower($var));
			if(isset($lang[$str]))
			{
				return $lang[$str];
			}
			return "{{$var}}"; //str_replace('_', ' ', $var);
		}
		return '';
	}

	//
	//
	// Functions added for USERGROUP MOD (optimized)
	//
	//
	function append_var_from_handle_to_block($blockname, $varname, $handle)
	{
		$this->assign_var_from_handle('_tmp', $handle);
		// assign the value of the generated variable to the given varname.
		$this->append_block_vars($blockname, array($varname => $this->vars['_tmp']));
		return true;
	}

	function append_block_vars($blockname, $vararray)
	{
		if(strstr($blockname, '.'))
		{
			// Nested block.
			$blocks = explode('.', $blockname);
			$blockcount = sizeof($blocks) - 1;
			$str = &$this->_tpldata;
			for($i = 0; $i < $blockcount; $i++)
			{
				$str = &$str[$blocks[$i].'.'];
				$str = &$str[sizeof($str)-1];
			}
			// Now we add the block that we're actually assigning to.
			// We're adding a new iteration to this block with the given
			//   variable assignments.
			$str = &$str[$blocks[$blockcount].'.'];
			$count = sizeof($str) - 1;
			if($count >= 0)
			{
				// adding only if there is at least one item
				$str[$count] = array_merge($str[$count], $vararray);
			}
		}
		else
		{
			// Top-level block.
			// Add a new iteration to this block with the variable assignments
			// we were given.
			$this->_tpldata[$blockname.'.'] = isset($this->_tpldata[$blockname.'.']) ? $this->_tpldata[$blockname.'.'] : $blockname;
			$str = &$this->_tpldata[$blockname.'.'];
			$count = sizeof($str) - 1;
			if($count >= 0)
			{
				// adding only if there is at least one item
				$str[$count] = array_merge($str[$count], $vararray);
			}
		}
		return true;
	}

	/*
	* Flush a root level block, so it becomes empty.
	*/
	function flush_block_vars($blockname)
	{
		// Top-level block.
		// flush a existing block we were given.
		$this->_tpldata[$blockname.'.'] = isset($this->_tpldata[$blockname.'.']) ? $this->_tpldata[$blockname.'.'] : $blockname;
		$current_iteration = sizeof($this->_tpldata[$blockname.'.']) - 1;
		unset($this->_tpldata[$blockname.'.']);
		return true;
	}

	/*
	* Add style configuration
	*/
	function _add_config($tpl, $add_vars = true)
	{
		global $phpbb_root_path, $mx_root_path;
		if(@file_exists($mx_root_path . 'templates/' . $tpl . '/xs_config.cfg'))
		{
			$style_config = array();
			include($mx_root_path . 'templates/' . $tpl . '/xs_config.cfg');
			if(count($style_config))
			{
				global $board_config, $db;
				for($i=0; $i<count($style_config); $i++)
				{
					$this->style_config[$style_config[$i]['var']] = $style_config[$i]['default'];
					if($add_vars)
					{
						$this->vars['TPL_CFG_' . strtoupper($style_config[$i]['var'])] = $style_config[$i]['default'];
					}
				}
				$str = $this->_serialize($this->style_config);
				$config_name = 'xs_style_' . $tpl;
				$board_config[$config_name] = $str;
				$sql = "INSERT INTO " . CONFIG_TABLE . " (config_name, config_value) VALUES ('" . str_replace('\\\'', '\'\'', addslashes($config_name)) . "', '" . str_replace('\\\'', '\'\'', addslashes($str)) . "')";
				$db->sql_query($sql);
				// recache config table for cat_hierarchy 2.1.0
				global $config;
				if(isset($config->data) && $config->data === $board_config && isset($config->data['mod_cat_hierarchy']))
				{
					$config->read(true);
				}
				return true;
			}
		}
		elseif(@file_exists($phpbb_root_path . 'templates/' . $tpl . '/xs_config.cfg'))
		{
			$style_config = array();
			include($phpbb_root_path . 'templates/' . $tpl . '/xs_config.cfg');
			if(count($style_config))
			{
				global $board_config, $db;
				for($i=0; $i<count($style_config); $i++)
				{
					$this->style_config[$style_config[$i]['var']] = $style_config[$i]['default'];
					if($add_vars)
					{
						$this->vars['TPL_CFG_' . strtoupper($style_config[$i]['var'])] = $style_config[$i]['default'];
					}
				}
				$str = $this->_serialize($this->style_config);
				$config_name = 'xs_style_' . $tpl;
				$board_config[$config_name] = $str;
				$sql = "INSERT INTO " . CONFIG_TABLE . " (config_name, config_value) VALUES ('" . str_replace('\\\'', '\'\'', addslashes($config_name)) . "', '" . str_replace('\\\'', '\'\'', addslashes($str)) . "')";
				$db->sql_query($sql);
				// recache config table for cat_hierarchy 2.1.0
				global $config;
				if(isset($config->data) && $config->data === $board_config && isset($config->data['mod_cat_hierarchy']))
				{
					$config->read(true);
				}
				return true;
			}
		}		
		return false;
	}

	function add_config($tpl)
	{
		$config_name = 'xs_style_' . $tpl;
		global $board_config;
		$result = false;
		if(empty($board_config[$config_name]))
		{
			$old = $this->style_config;
			$result = $this->_add_config($tpl, false);
			$this->style_config = $old;
		}
		return $result;
	}

	/*
	* Refresh config data
	*/
	function _refresh_config($tpl, $add_vars = false)
	{
		global $mx_root_path, $phpbb_root_path;
		if(@file_exists($mx_root_path . 'templates/' . $tpl . '/xs_config.cfg'))
		{
			$style_config = array();
			include($mx_root_path . 'templates/' . $tpl . '/xs_config.cfg');
			if(count($style_config))
			{
				global $board_config, $db;
				for($i=0; $i<count($style_config); $i++)
				{
					if(!isset($this->style_config[$style_config[$i]['var']]))
					{
						$this->style_config[$style_config[$i]['var']] = $style_config[$i]['default'];
						if($add_vars)
						{
							$this->vars['TPL_CFG_' . strtoupper($style_config[$i]['var'])] = $style_config[$i]['default'];
						}
					}
				}
				$str = $this->_serialize($this->style_config);
				$config_name = 'xs_style_' . $tpl;
				if(isset($board_config[$config_name]))
				{
					$sql = "UPDATE " . CONFIG_TABLE . " SET config_value='" . str_replace('\\\'', '\'\'', addslashes($str)) . "' WHERE config_name='" . str_replace('\\\'', '\'\'', addslashes($config_name)) . "'";
				}
				else
				{
					$sql = "INSERT INTO " . CONFIG_TABLE . " (config_name, config_value) VALUES ('" . str_replace('\\\'', '\'\'', addslashes($config_name)) . "', '" . str_replace('\\\'', '\'\'', addslashes($str)) . "')";
				}
				$db->sql_query($sql);
				$board_config[$config_name] = $str;
				// recache config table for cat_hierarchy 2.1.0
				global $config;
				if(isset($config->data) && $config->data === $board_config && isset($config->data['mod_cat_hierarchy']))
				{
					$config->read(true);
				}
				return true;
			}
		}
		elseif(@file_exists($phpbb_root_path . 'templates/' . $tpl . '/xs_config.cfg'))
		{
			$style_config = array();
			include($phpbb_root_path . 'templates/' . $tpl . '/xs_config.cfg');
			if(count($style_config))
			{
				global $board_config, $db;
				for($i = 0; $i < count($style_config); $i++)
				{
					if(!isset($this->style_config[$style_config[$i]['var']]))
					{
						$this->style_config[$style_config[$i]['var']] = $style_config[$i]['default'];
						if($add_vars)
						{
							$this->vars['TPL_CFG_' . strtoupper($style_config[$i]['var'])] = $style_config[$i]['default'];
						}
					}
				}
				$str = $this->_serialize($this->style_config);
				$config_name = 'xs_style_' . $tpl;
				if(isset($board_config[$config_name]))
				{
					$sql = "UPDATE " . CONFIG_TABLE . " SET config_value='" . str_replace('\\\'', '\'\'', addslashes($str)) . "' WHERE config_name='" . str_replace('\\\'', '\'\'', addslashes($config_name)) . "'";
				}
				else
				{
					$sql = "INSERT INTO " . CONFIG_TABLE . " (config_name, config_value) VALUES ('" . str_replace('\\\'', '\'\'', addslashes($config_name)) . "', '" . str_replace('\\\'', '\'\'', addslashes($str)) . "')";
				}
				$db->sql_query($sql);
				$board_config[$config_name] = $str;
				// recache config table for cat_hierarchy 2.1.0
				global $board_config;
				if(isset($board_config['mod_cat_hierarchy']))
				{
					$config->read(true);
				}
				return true;
			}
		}		
		return false;
	}

	function refresh_config($tpl = '')
	{
		if($tpl === '')
		{
			$tpl = $this->tpl;
		}
		if($tpl == $this->tpl)
		{
			$result = $this->_refresh_config($tpl, true);
		}
		else
		{
			$old = $this->style_config;
			$result = $this->_refresh_config($tpl, false);
			$this->style_config = $old;
		}
		return $result;
	}

	/*
	* Get style configuration
	*/
	function _get_config($tpl, $add_config)
	{
		$this->style_config = array();
		if(empty($tpl))
		{
			$tpl = $this->tpl;
		}
		$config_name = 'xs_style_' . $tpl;
		global $board_config;
		if(empty($board_config[$config_name]))
		{
			if($add_config)
			{
				$this->_add_config($tpl, $tpl === $this->tpl ? true : false);
			}
			return $this->style_config;
		}
		$this->style_config = $this->_unserialize($board_config[$config_name]);
		if($tpl === $this->tpl)
		{
			foreach($this->style_config as $var => $value)
			{
				$this->vars['TPL_CFG_' . strtoupper($var)] = $value;
			}
		}
		return $this->style_config;
	}

	function get_config($tpl = '', $add_config = true)
	{
		if(empty($tpl))
		{
			if(empty($this->tpl))
			{
				return array();
			}
			$this->_get_config($this->tpl, $add_config);
			return $this->style_config;
		}
		else
		{
			$old_config = $this->style_config;
			$result = $this->_get_config($tpl, $add_config);
			$this->style_config = $old_config;
			return $result;
		}
	}

	/*
	* Split/merge config data.
	* Using this function instead of (un)serialize because it generates smaller string so it can be stored in phpbb_config
	*/
	function _serialize($array)
	{
		if(!is_array($array))
		{
			return '';
		}
		$str = '';
		foreach($array as $var => $value)
		{
			if($str)
			{
				$str .= '|';
			}
			$str .= $var . '=' . str_replace('|', '', $value);
		}
		return $str;
	}
	
	function _unserialize($str)
	{
		$array = array();
		$list = explode('|', $str);
		for($i=0; $i<count($list); $i++)
		{
			$row = explode('=', $list[$i], 2);
			if(count($row) == 2)
			{
				$array[$row[0]] = $row[1];
			}
		}
		return $array;
	}
	
	/**
	* Change already assigned key variable pair (one-dimensional - single loop entry)
	*
	* An example of how to use this function:
	* {@example alter_block_array.php}
	*
	* @param	string	$blockname	the blockname, for example 'loop'
	* @param	array	$vararray	the var array to insert/add or merge
	* @param	mixed	$key		Key to search for
	*
	* array: KEY => VALUE [the key/value pair to search for within the loop to determine the correct position]
	*
	* int: Position [the position to change or insert at directly given]
	*
	* If key is false the position is set to 0
	* If key is true the position is set to the last entry
	*
	* @param	string	$mode		Mode to execute (valid modes are 'insert' and 'change')
	*
	*	If insert, the vararray is inserted at the given position (position counting from zero).
	*	If change, the current block gets merged with the vararray (resulting in new key/value pairs be added and existing keys be replaced by the new value).
	*
	* Since counting begins by zero, inserting at the last position will result in this array: array(vararray, last positioned array)
	* and inserting at position 1 will result in this array: array(first positioned array, vararray, following vars)
	*
	* @return bool false on error, true on success
	* @access public
	*/
	function alter_block_array($blockname, $vararray, $key = false, $mode = 'insert')
	{
		if (strpos($blockname, '.') !== false)
		{
			// Nested blocks are not supported
			return false;
		}

		// Change key to zero (change first position) if false and to last position if true
		if ($key === false || $key === true)
		{
			$key = ($key === false) ? 0 : sizeof($this->_tpldata[$blockname]);
		}

		// Get correct position if array given
		if (is_array($key))
		{
			// Search array to get correct position
			list($search_key, $search_value) = @each($key);

			$key = NULL;
			foreach ($this->_tpldata[$blockname] as $i => $val_ary)
			{
				if ($val_ary[$search_key] === $search_value)
				{
					$key = $i;
					break;
				}
			}

			// key/value pair not found
			if ($key === NULL)
			{
				return false;
			}
		}

		// Insert Block
		if ($mode == 'insert')
		{
			// Make sure we are not exceeding the last iteration
			if ($key >= sizeof($this->_tpldata[$blockname]))
			{
				$key = sizeof($this->_tpldata[$blockname]);
				unset($this->_tpldata[$blockname][($key - 1)]['S_LAST_ROW']);
				$vararray['S_LAST_ROW'] = true;
			}
			else if ($key === 0)
			{
				unset($this->_tpldata[$blockname][0]['S_FIRST_ROW']);
				$vararray['S_FIRST_ROW'] = true;
			}

			// Re-position template blocks
			for ($i = sizeof($this->_tpldata[$blockname]); $i > $key; $i--)
			{
				$this->_tpldata[$blockname][$i] = $this->_tpldata[$blockname][$i-1];
				$this->_tpldata[$blockname][$i]['S_ROW_COUNT'] = $i;
			}

			// Insert vararray at given position
			$vararray['S_ROW_COUNT'] = $key;
			$this->_tpldata[$blockname][$key] = $vararray;

			return true;
		}

		// Which block to change?
		if ($mode == 'change')
		{
			if ($key == sizeof($this->_tpldata[$blockname]))
			{
				$key--;
			}

			$this->_tpldata[$blockname][$key] = array_merge($this->_tpldata[$blockname][$key], $vararray);
			return true;
		}

		return false;
	}

	/**
	* Include a separate template
	* @access private
	*/
	function _tpl_include($filename, $include = true)
	{
		$handle = $filename;
		$this->filename[$handle] = $filename;
		$this->files[$handle] = $this->root . '/' . $filename;
		/** */
		$this->set_filename($handle, $filename);
		/** */		
		if ($this->inherit_root)
		{
			$this->files_inherit[$handle] = $this->inherit_root . '/' . $filename;
		}

		$filename = $this->_tpl_load($handle);

		if ($include)
		{
			global $mx_user;

			if ($filename)
			{
				include($filename);
				return;
			}
			eval(' ?>' . $this->compiled_code[$handle] . '<?php ');
		}
	}

	/**
	* Include a php-file
	* @access private
	*/
	function _php_include($filename)
	{
		global $mx_root_path, $phpbb_root_path;

		$file = $mx_root_path . $filename;
		if (file_exists($file))
		{
			include($file);
		}
		
		$file = $phpbb_root_path . $filename;
		if (file_exists($file))
		{
			include($file);
		}
		
		if (!file_exists($mx_root_path . $filename) && !file_exists($phpbb_root_path . $filename))
		{
			// trigger_error cannot be used here, as the output already started
			//echo 'template->_php_include(): File ' . htmlspecialchars($filename) . ' does not exist or is empty';
			return;
		}	
	}

	public function set_environment()
	{
		$this->env = '';
	}

	public function tokenize($code, $filename = null)
	{
		// Our phpBB tags
		// Commented out tokens are handled separately from the main replace
		$phpbb_tags = array(
			/*'BEGIN',
			'BEGINELSE',
			'END',
			'IF',
			'ELSE',
			'ELSEIF',
			'ENDIF',
			'DEFINE',
			'UNDEFINE',*/
			'ENDDEFINE',
			'INCLUDE',
			'INCLUDEPHP',
			'INCLUDEJS',
			'INCLUDECSS',
			'PHP',
			'ENDPHP',
			'EVENT',
		);

		// Twig tag masks
		/**
		 * Remove whitespaces between HTML tags.
		 *
		 * <pre>
		 * {% spaceless %}
		 *      <div>
		 *          <strong>foo</strong>
		 *      </div>
		 * {% endspaceless %}
		 *
		 * {# output will be <div><strong>foo</strong></div> #}
		 * </pre>
		 *
		 */		
		$twig_tags = array(
			'autoescape',
			'endautoescape',
			'if',
			'elseif',
			'else',
			'endif',
			'block',
			'endblock',
			'use',
			'extends',
			'embed',
			'filter',
			'endfilter',
			'flush',
			'for',
			'endfor',
			'macro',
			'endmacro',
			'import',
			'from',
			'sandbox',
			'endsandbox',
			'set',
			'endset',
			//'spaceless',
			//'endspaceless',
			'verbatim',
			'endverbatim',
		);

		// Fix tokens that may have inline variables (e.g. <!-- DEFINE $TEST = '{FOO}')
		$code = $this->strip_surrounding_quotes(array(
			'INCLUDE',
			'INCLUDEPHP',
			'INCLUDEJS',
			'INCLUDECSS',
		), $code);
		$code = $this->fix_inline_variable_tokens(array(
			'DEFINE \$[a-zA-Z0-9_]+ =',
			'INCLUDE',
			'INCLUDEPHP',
			'INCLUDEJS',
			'INCLUDECSS',
		), $code);
		$code = $this->add_surrounding_quotes(array(
			'INCLUDE',
			'INCLUDEPHP',
			'INCLUDEJS',
			'INCLUDECSS',
		), $code);

		// Fix our BEGIN statements
		$code = $this->fix_begin_tokens($code);

		// Fix our IF tokens
		$code = $this->fix_if_tokens($code);

		// Fix our DEFINE tokens
		$code = $this->fix_define_tokens($code);

		// Replace all of our starting tokens, <!-- TOKEN --> with Twig style, {% TOKEN %}
		// This also strips outer parenthesis, <!-- IF (blah) --> becomes <!-- IF blah -->
		$code = preg_replace('#<!-- (' . implode('|', $phpbb_tags) . ')(?: (.*?) ?)?-->#', '{% $1 $2 %}', $code);

		// Replace all of our twig masks with Twig code (e.g. <!-- BLOCK .+ --> with {% block $1 %})
		$code = $this->replace_twig_tag_masks($code, $twig_tags);

		// Replace all of our language variables, {L_VARNAME}, with Twig style, {{ lang('NAME') }}
		// Appends any filters after lang()
		$code = preg_replace('#{L_([a-zA-Z0-9_\.]+)(\|[^}]+?)?}#', '{{ lang(\'$1\')$2 }}', $code);

		// Replace all of our escaped language variables, {LA_VARNAME}, with Twig style, {{ lang('NAME')|escape('js') }}
		// Appends any filters after lang(), but before escape('js')
		$code = preg_replace('#{LA_([a-zA-Z0-9_\.]+)(\|[^}]+?)?}#', '{{ lang(\'$1\')$2|escape(\'js\') }}', $code);

		// Replace all of our variables, {VARNAME}, with Twig style, {{ VARNAME }}
		// Appends any filters
		$code = preg_replace('#{([a-zA-Z0-9_\.]+)(\|[^}]+?)?}#', '{{ $1$2 }}', $code);

		// Tokenize \Twig_Source instance
		return $code;
	}

	/**
	* Strip surrounding quotes
	*
	* First step to fix tokens that may have inline variables
	* E.g. <!-- INCLUDE '{TEST}.html' to <!-- INCLUDE {TEST}.html
	*
	* @param array $tokens array of tokens to search for (imploded to a regular expression)
	* @param string $code
	* @return string
	*/
	protected function strip_surrounding_quotes($tokens, $code)
	{
		// Remove matching quotes at the beginning/end if a statement;
		// E.g. 'asdf'"' -> asdf'"
		// E.g. "asdf'"" -> asdf'"
		// E.g. 'asdf'" -> 'asdf'"
		return preg_replace('#<!-- (' . implode('|', $tokens) . ') (([\'"])?(.*?)\1) -->#', '<!-- $1 $2 -->', $code);
	}

	/**
	* Fix tokens that may have inline variables
	*
	* Second step to fix tokens that may have inline variables
	* E.g. <!-- INCLUDE '{TEST}.html' to <!-- INCLUDE ' ~ {TEST} ~ '.html
	*
	* @param array $tokens array of tokens to search for (imploded to a regular expression)
	* @param string $code
	* @return string
	*/
	protected function fix_inline_variable_tokens($tokens, $code)
	{
		$callback = function($matches)
		{
			// Replace template variables with start/end to parse variables (' ~ TEST ~ '.html)
			$matches[2] = preg_replace('#{([a-zA-Z0-9_\.$]+)}#', "'~ \$1 ~'", $matches[2]);

			return "<!-- {$matches[1]} {$matches[2]} -->";
		};

		return preg_replace_callback('#<!-- (' . implode('|', $tokens) . ') (.+?) -->#', $callback, $code);
	}

	/**
	* Add surrounding quotes
	*
	* Last step to fix tokens that may have inline variables
	* E.g. <!-- INCLUDE '{TEST}.html' to <!-- INCLUDE '' ~ {TEST} ~ '.html'
	*
	* @param array $tokens array of tokens to search for (imploded to a regular expression)
	* @param string $code
	* @return string
	*/
	protected function add_surrounding_quotes($tokens, $code)
	{
		return preg_replace('#<!-- (' . implode('|', $tokens) . ') (.+?) -->#', '<!-- $1 \'$2\' -->', $code);
	}

	/**
	* Fix begin tokens (convert our BEGIN to Twig for)
	*
	* Not meant to be used outside of this context, public because the anonymous function calls this
	*
	* @param string $code
	* @param array $parent_nodes (used in recursion)
	* @return string
	*/
	public function fix_begin_tokens($code, $parent_nodes = array())
	{
		// PHP 5.3 cannot use $this in an anonymous function, so use this as a work-around
		$parent_class = $this;
		$callback = function ($matches) use ($parent_class, $parent_nodes)
		{
			$hard_parents = explode('.', $matches[1]);
			array_pop($hard_parents); // ends with .
			if ($hard_parents)
			{
				$parent_nodes = array_merge($hard_parents, $parent_nodes);
			}

			$name = $matches[2];
			$subset = trim(substr($matches[3], 1, -1)); // Remove parenthesis
			$body = $matches[4];

			// Replace <!-- BEGINELSE -->
			$body = str_replace('<!-- BEGINELSE -->', '{% else %}', $body);

			// Is the designer wanting to call another loop in a loop?
			// <!-- BEGIN loop -->
			// <!-- BEGIN !loop2 -->
			// <!-- END !loop2 -->
			// <!-- END loop -->
			// 'loop2' is actually on the same nesting level as 'loop' you assign
			// variables to it with template->assign_block_vars('loop2', array(...))
			if (strpos($name, '!') === 0)
			{
				// Count the number if ! occurrences
				$count = substr_count($name, '!');
				for ($i = 0; $i < $count; $i++)
				{
					array_pop($parent_nodes);
					$name = substr($name, 1);
				}
			}

			// Remove all parent nodes, e.g. foo, bar from foo.bar.foobar.VAR
			foreach ($parent_nodes as $node)
			{
				$body = preg_replace('#([^a-zA-Z0-9_])' . $node . '\.([a-zA-Z0-9_]+)\.#', '$1$2.', $body);
			}

			// Add current node to list of parent nodes for child nodes
			$parent_nodes[] = $name;

			// Recursive...fix any child nodes
			$body = $parent_class->fix_begin_tokens($body, $parent_nodes);

			// Need the parent variable name
			array_pop($parent_nodes);
			$parent = (!empty($parent_nodes)) ? end($parent_nodes).'.' : '';

			if ($subset !== '')
			{
				$subset = '|subset(' . $subset . ')';
			}

			$parent = ($parent) ? $parent : 'loops.';
			// Turn into a Twig for loop
			return "{% for {$name} in {$parent}{$name}{$subset} %}{$body}{% endfor %}";
		};

		return preg_replace_callback('#<!-- BEGIN ((?:[a-zA-Z0-9_]+\.)*)([!a-zA-Z0-9_]+)(\([0-9,\-]+\))? -->(.+?)<!-- END \1\2 -->#s', $callback, $code);
	}
	
	/**
	* Fix begin tokens (convert our Twig to  BEGIN for)
	*
	* Not meant to be used outside of this context, public because the anonymous function calls this
	*
	* @param string $code
	* @param array $parent_nodes (used in recursion)
	* @return string
	*/
	public function fix_tokens_begin($code, $parent_nodes = array())
	{
		// PHP 5.3 cannot use $this in an anonymous function, so use this as a work-around
		$parent_class = $this;
		$callback = function ($matches) use ($parent_class, $parent_nodes)
		{
			$hard_parents = explode('.', $matches[1]);
			array_pop($hard_parents); // ends with .
			if ($hard_parents)
			{
				$parent_nodes = array_merge($hard_parents, $parent_nodes);
			}

			$name = $matches[2];
			$subset = trim(substr($matches[3], 1, -1)); // Remove parenthesis
			$body = $matches[4];

			// Replace <!-- BEGINELSE -->
			$body = str_replace('{% else %}', '<!-- BEGINELSE -->', $body);

			// Is the designer wanting to call another loop in a loop?
			// <!-- BEGIN loop -->
			// <!-- BEGIN !loop2 -->
			// <!-- END !loop2 -->
			// <!-- END loop -->
			// 'loop2' is actually on the same nesting level as 'loop' you assign
			// variables to it with template->assign_block_vars('loop2', array(...))
			if (strpos($name, '!') === 0)
			{
				// Count the number if ! occurrences
				$count = substr_count($name, '!');
				for ($i = 0; $i < $count; $i++)
				{
					array_pop($parent_nodes);
					$name = substr($name, 1);
				}
			}

			// Remove all parent nodes, e.g. foo, bar from foo.bar.foobar.VAR
			foreach ($parent_nodes as $node)
			{
				$body = preg_replace('#([^a-zA-Z0-9_])' . $node . '\.([a-zA-Z0-9_]+)\.#', ' $1 $2 . ', $body);
			}

			// Add current node to list of parent nodes for child nodes
			$parent_nodes[] = $name;

			// Recursive...fix any child nodes
			$body = $parent_class->fix_tokens_begin($body, $parent_nodes);

			// Need the parent variable name
			array_pop($parent_nodes);
			$parent = (!empty($parent_nodes)) ? end($parent_nodes) . '.' : '';

			if ($subset !== '')
			{
				$subset = '|subset(' . $subset . ')';
			}

			$parent = ($parent) ? $parent : 'loops.';
			// loop
			return "<!-- FOR {$name} in {$parent}{$name}{$subset} -->{$body}<!-- ENDFOR -->";
		};

		return preg_replace_callback('#<!-- BEGIN ((?:[a-zA-Z0-9_]+\.)*)([!a-zA-Z0-9_]+)(\([0-9,\-]+\))? -->(.+?)<!-- END \1\2 -->#s', $callback, $code);
	}
	
	/**
	* Fix IF statements
	*
	* @param string $code
	* @return string
	*/
	protected function fix_if_tokens($code)
	{
		// Replace ELSE IF with ELSEIF
		$code = preg_replace('#<!-- ELSE IF (.+?) -->#', '<!-- ELSEIF $1 -->', $code);

		// Replace our "div by" with Twig's divisibleby (Twig does not like test names with spaces)
		$code = preg_replace('# div by ([0-9]+)#', ' divisibleby($1)', $code);

		$callback = function($matches)
		{
			$inner = $matches[2];
			// Replace $TEST with definition.TEST
			$inner = preg_replace('#(\s\(*!?)\$([a-zA-Z_0-9]+)#', '$1definition.$2', $inner);

			// Replace .foo with loops.foo|length
			// $inner = preg_replace('#(\s\(*!?)\.([a-zA-Z_0-9]+)([^a-zA-Z_0-9\.])#', '$1loops.$2|length$3', $inner);

			// Replace .foo.bar with foo.bar|length
			// $inner = preg_replace('#(\s\(*!?)\.([a-zA-Z_0-9\.]+)([^a-zA-Z_0-9\.])#', '$1$2|length$3', $inner);

			return "<!-- {$matches[1]}IF{$inner}-->";
		};

		return preg_replace_callback('#<!-- (ELSE)?IF((.*?) (?:\(*!?[\$|\.]([^\s]+)(.*?))?)-->#', $callback, $code);
	}

	/**
	* Fix DEFINE statements and {$VARNAME} variables
	*
	* @param string $code
	* @return string
	*/
	protected function fix_define_tokens($code)
	{
		/**
		* Changing $VARNAME to definition.varname because set is only local
		* context (e.g. DEFINE $TEST will only make $TEST available in current
		* template and any child templates, but not any parent templates).
		*
		* DEFINE handles setting it properly to definition in its node, but the
		* variables reading FROM it need to be altered to definition.VARNAME
		*
		* Setting up definition as a class in the array passed to Twig
		* ($context) makes set definition.TEST available in the global context
		*/

		// Replace <!-- DEFINE $NAME with {% DEFINE definition.NAME
		$code = preg_replace('#<!-- DEFINE \$(.*?) -->#', '{% DEFINE $1 %}', $code);

		// Changing UNDEFINE NAME to DEFINE NAME = null to save from creating an extra token parser/node
		$code = preg_replace('#<!-- UNDEFINE \$(.*?)-->#', '{% DEFINE $1= null %}', $code);

		// Replace all of our variables, {$VARNAME}, with Twig style, {{ definition.VARNAME }}
		$code = preg_replace('#{\$([a-zA-Z0-9_\.]+)}#', '{{ definition.$1 }}', $code);

		// Replace all of our variables, ~ $VARNAME ~, with Twig style, ~ definition.VARNAME ~
		$code = preg_replace('#~ \$([a-zA-Z0-9_\.]+) ~#', '~ definition.$1 ~', $code);

		return $code;
	}
	
	/**
	* Fix DEFINE statements and {$VARNAME} variables
	*
	* @param string $code
	* @return string
	*/
	protected function fix_tokens_define($code)
	{
		/**
		* Changing $VARNAME to definition.varname because set is only local
		* context (e.g. DEFINE $TEST will only make $TEST available in current
		* template and any child templates, but not any parent templates).
		*
		* DEFINE handles setting it properly to definition in its node, but the
		* variables reading FROM it need to be altered to definition.VARNAME
		*
		* Setting up definition as a class in the array passed to Twig
		* ($context) makes set definition.TEST available in the global context
		*/

		// Replace <!-- DEFINE $NAME with {% DEFINE definition.NAME
		$code = preg_replace('#{% DEFINE \$(.*?) %}#', '<!-- DEFINE $1 -->', $code);

		// Changing UNDEFINE NAME to DEFINE NAME = null to save from creating an extra token parser/node
		$code = preg_replace('#{% UNDEFINE \$(.*?)%}#', '<!-- DEFINE $1= null -->', $code);

		// Replace all of our variables, {$VARNAME}, with Twig style, {{ definition.VARNAME }}
		//$code = preg_replace('#{\$([a-zA-Z0-9_\.]+)}#', '{{ definition.$1 }}', $code);

		// Replace all of our variables, ~ $VARNAME ~, with Twig style, ~ definition.VARNAME ~
		//$code = preg_replace('#~ \$([a-zA-Z0-9_\.]+) ~#', '~ definition.$1 ~', $code);

		return $code;
	}
	
	/**
	* Replace Twig tag masks with Twig tag calls
	*
	* E.g. <!-- BLOCK foo --> with {% block foo %}
	*
	* @param string $code
	* @param array $twig_tags All tags we want to create a mask for
	* @return string
	*/
	protected function replace_twig_tag_masks($code, $twig_tags)
	{
		$callback = function ($matches)
		{
			$matches[1] = strtolower($matches[1]);

			return "{% {$matches[1]}{$matches[2]}%}";
		};

		foreach ($twig_tags as &$tag)
		{
			$tag = strtoupper($tag);
		}

		// twig_tags is an array of the twig tags, which are all lowercase, but we use all uppercase tags
		$code = preg_replace_callback('#<!-- (' . implode('|', $twig_tags) . ')(.*?)-->#', $callback, $code);

		return $code;
	}
	
	/**
	* Replace Twig tag masks with Twig tag calls
	*
	* E.g. <!-- BLOCK foo --> with {% block foo %}
	*
	* @param string $code
	* @param array $twig_tags All tags we want to create a mask for
	* @return string
	*/
	protected function replace_tag_twig_masks($code, $twig_tags)
	{
		$callback = function ($matches)
		{
			$matches[1] = strtolower($matches[1]);

			return "<!-- {$matches[1]}{$matches[2]}-->";
		};

		foreach ($twig_tags as &$tag)
		{
			$tag = strtoupper($tag);
		}

		// twig_tags is an array of the twig tags, which are all lowercase, but we use all uppercase tags
		$code = preg_replace_callback('#{% (' . implode('|', $twig_tags) . ')(.*?)%}#', $callback, $code);

		return $code;
	}	
}

/**
* This class holds all DEFINE variables from the current page load
*/
class definition
{
	/** @var array **/
	protected $definitions = array();

	/**
	* Get a DEFINE'd variable
	*
	* @param string $name
	* @param array $arguments
	*
	* @return mixed Null if not found
	*/
	public function __call($name, $arguments)
	{
		return (isset($this->definitions[$name])) ? $this->definitions[$name] : null;
	}

	/**
	* DEFINE a variable
	*
	* @param string $name
	* @param mixed $value
	* @return \phpbb\template\twig\definition
	*/
	public function set($name, $value)
	{
		$this->definitions[$name] = $value;

		return $this;
	}

	/**
	* Append to a variable
	*
	* @param string $name
	* @param string $value
	* @return \phpbb\template\twig\definition
	*/
	public function append($name, $value)
	{
		if (!isset($this->definitions[$name]))
		{
			$this->definitions[$name] = '';
		}

		$this->definitions[$name] .= $value;

		return $this;
	}
}

function xs_switch($tpl, $name)
{
	return (isset($tpl->_tpldata[$name.'.']) && count($tpl->_tpldata[$name.'.']) > 0);
}

?>